// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`BinaryExpression ampersand 1`] = `
"; ModuleID = 'binary-expression/ampersand.ts'
source_filename = \\"binary-expression/ampersand.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_ampersand() {
entry:
  %numberValue = alloca double, align 8
  %intValue = alloca i32, align 4
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %and = and i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  store double 3.400000e+00, double* %numberValue, align 8
  %intValue2 = load i32, i32* %intValue, align 4
  %and3 = and i32 %intValue2, 2
  store i32 %and3, i32* %intValue, align 4
  ret void
}

; Function Attrs: alwaysinline readnone
declare i32 @toInt32d(double) #0

attributes #0 = { alwaysinline readnone }
"
`;

exports[`BinaryExpression ampersand-ampersand 1`] = `
"; ModuleID = 'binary-expression/ampersand-ampersand.ts'
source_filename = \\"binary-expression/ampersand-ampersand.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_ampersandAmpersand() {
entry:
  %six = alloca i32, align 4
  store i32 6, i32* %six, align 4
  br i1 true, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  br label %land.end

land.end:                                         ; preds = %land.lhs.true, %entry
  %land = phi i1 [ true, %entry ], [ true, %land.lhs.true ]
  br i1 %land, label %land.lhs.true1, label %land.end2

land.lhs.true1:                                   ; preds = %land.end
  br label %land.end2

land.end2:                                        ; preds = %land.lhs.true1, %land.end
  %land3 = phi i1 [ %land, %land.end ], [ false, %land.lhs.true1 ]
  br i1 true, label %land.lhs.true4, label %land.end5

land.lhs.true4:                                   ; preds = %land.end2
  br label %land.end5

land.end5:                                        ; preds = %land.lhs.true4, %land.end2
  %land6 = phi i32 [ 10, %land.end2 ], [ 3, %land.lhs.true4 ]
  %land6AsBool = icmp ne i32 %land6, 0
  br i1 %land6AsBool, label %land.lhs.true7, label %land.end8

land.lhs.true7:                                   ; preds = %land.end5
  br label %land.end8

land.end8:                                        ; preds = %land.lhs.true7, %land.end5
  %land9 = phi i32 [ %land6, %land.end5 ], [ 1, %land.lhs.true7 ]
  ret void
}
"
`;

exports[`BinaryExpression asterisk 1`] = `
"; ModuleID = 'binary-expression/asterisk.ts'
source_filename = \\"binary-expression/asterisk.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_asterisk() {
entry:
  %doubleProduct = alloca double, align 8
  %intProduct = alloca i32, align 4
  store i32 12, i32* %intProduct, align 4
  %intProduct1 = load i32, i32* %intProduct, align 4
  %mul = mul i32 %intProduct1, 2
  store i32 %mul, i32* %intProduct, align 4
  store double 1.200000e+01, double* %doubleProduct, align 8
  %doubleProduct2 = load double, double* %doubleProduct, align 8
  %mul3 = fmul double %doubleProduct2, 1.500000e+00
  store double %mul3, double* %doubleProduct, align 8
  ret void
}
"
`;

exports[`BinaryExpression asterisk-asterisk 1`] = `
"; ModuleID = 'binary-expression/asterisk-asterisk.ts'
source_filename = \\"binary-expression/asterisk-asterisk.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_asteriskAsterisk() {
entry:
  %doubleProduct = alloca double, align 8
  %intProduct = alloca double, align 8
  %mathPtr = load %class.Math*, %class.Math** @Math_ptr, align 4
  %powReturnValue = call double @Math_powdd(%class.Math* %mathPtr, double 3.000000e+00, double 4.000000e+00)
  store double %powReturnValue, double* %intProduct, align 8
  %intProduct1 = load double, double* %intProduct, align 8
  %mathPtr2 = load %class.Math*, %class.Math** @Math_ptr, align 4
  %powReturnValue3 = call double @Math_powdd(%class.Math* %mathPtr2, double %intProduct1, double 2.000000e+00)
  store double %powReturnValue3, double* %intProduct, align 8
  %mathPtr4 = load %class.Math*, %class.Math** @Math_ptr, align 4
  %powReturnValue5 = call double @Math_powdd(%class.Math* %mathPtr4, double 3.000000e+00, double 4.000000e+00)
  store double %powReturnValue5, double* %doubleProduct, align 8
  %doubleProduct6 = load double, double* %doubleProduct, align 8
  %mathPtr7 = load %class.Math*, %class.Math** @Math_ptr, align 4
  %powReturnValue8 = call double @Math_powdd(%class.Math* %mathPtr7, double %doubleProduct6, double 1.500000e+00)
  store double %powReturnValue8, double* %doubleProduct, align 8
  ret void
}

; Function Attrs: alwaysinline nounwind readnone
declare double @Math_powdd(%class.Math* readonly dereferenceable(1), double, double) #0

attributes #0 = { alwaysinline nounwind readnone }
"
`;

exports[`BinaryExpression asterisk-implicit-cast 1`] = `
"; ModuleID = 'binary-expression/asterisk-implicit-cast.ts'
source_filename = \\"binary-expression/asterisk-implicit-cast.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_asteriskImplicitCast() {
entry:
  %result = alloca double, align 8
  store double 1.200000e+01, double* %result, align 8
  ret void
}
"
`;

exports[`BinaryExpression bar 1`] = `
"; ModuleID = 'binary-expression/bar.ts'
source_filename = \\"binary-expression/bar.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_bar() {
entry:
  %intToInt = alloca i32, align 4
  %intValue = alloca i32, align 4
  %six = alloca i32, align 4
  store i32 6, i32* %six, align 4
  %six1 = load i32, i32* %six, align 4
  %or = or i32 %six1, 8
  store i32 %or, i32* %six, align 4
  %AsInt32 = call i32 @toInt32d(double 3.560000e+00)
  store i32 %AsInt32, i32* %intValue, align 4
  store i32 3, i32* %intToInt, align 4
  ret void
}

; Function Attrs: alwaysinline readnone
declare i32 @toInt32d(double) #0

attributes #0 = { alwaysinline readnone }
"
`;

exports[`BinaryExpression bar-bar 1`] = `
"; ModuleID = 'binary-expression/bar-bar.ts'
source_filename = \\"binary-expression/bar-bar.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_barBar() {
entry:
  %six = alloca i32, align 4
  store i32 6, i32* %six, align 4
  %six1 = load i32, i32* %six, align 4
  %six1AsBool = icmp ne i32 %six1, 0
  %not = xor i1 %six1AsBool, true
  %not2 = xor i1 %not, true
  br i1 %not2, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  br label %lor.end

lor.end:                                          ; preds = %lor.lhs.false, %entry
  %lor = phi i1 [ %not2, %entry ], [ true, %lor.lhs.false ]
  br i1 %lor, label %lor.end4, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.end
  br label %lor.end4

lor.end4:                                         ; preds = %lor.lhs.false3, %lor.end
  %lor5 = phi i1 [ %lor, %lor.end ], [ false, %lor.lhs.false3 ]
  br i1 true, label %lor.end7, label %lor.lhs.false6

lor.lhs.false6:                                   ; preds = %lor.end4
  br label %lor.end7

lor.end7:                                         ; preds = %lor.lhs.false6, %lor.end4
  %lor8 = phi i32 [ 10, %lor.end4 ], [ 3, %lor.lhs.false6 ]
  %lor8AsBool = icmp ne i32 %lor8, 0
  br i1 %lor8AsBool, label %lor.end10, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.end7
  br label %lor.end10

lor.end10:                                        ; preds = %lor.lhs.false9, %lor.end7
  %lor11 = phi i32 [ %lor8, %lor.end7 ], [ 1, %lor.lhs.false9 ]
  ret void
}
"
`;

exports[`BinaryExpression caret 1`] = `
"; ModuleID = 'binary-expression/caret.ts'
source_filename = \\"binary-expression/caret.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_caret() {
entry:
  %numberValue = alloca double, align 8
  %intValue = alloca i32, align 4
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %xor = xor i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  store double 3.400000e+00, double* %numberValue, align 8
  %intValue2 = load i32, i32* %intValue, align 4
  %xor3 = xor i32 %intValue2, 2
  store i32 %xor3, i32* %intValue, align 4
  ret void
}

; Function Attrs: alwaysinline readnone
declare i32 @toInt32d(double) #0

attributes #0 = { alwaysinline readnone }
"
`;

exports[`BinaryExpression comma 1`] = `
"; ModuleID = 'binary-expression/comma.ts'
source_filename = \\"binary-expression/comma.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_comma() {
entry:
  %z = alloca double, align 8
  %y = alloca double, align 8
  %x = alloca i32, align 4
  store i32 10, i32* %x, align 4
  store double 2.022000e+01, double* %y, align 8
  store double 2.022000e+01, double* %z, align 8
  ret void
}
"
`;

exports[`BinaryExpression equals-equals-equals 1`] = `
"; ModuleID = 'binary-expression/equals-equals-equals.ts'
source_filename = \\"binary-expression/equals-equals-equals.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.EqualsTest = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@EqualsTest_name = private unnamed_addr constant [11 x i8] c\\"EqualsTest\\\\00\\"
@EqualsTest_type_descriptor = private constant { [11 x i8]* } { [11 x i8]* @EqualsTest_name }

define void @_equalsEqualsEqualsToken() {
entry:
  %trueValue = alloca i1, align 1
  %threePointFour = alloca double, align 8
  %four = alloca i32, align 4
  store i32 4, i32* %four, align 4
  store double 3.400000e+00, double* %threePointFour, align 8
  store i1 true, i1* %trueValue, align 1
  %four1 = load i32, i32* %four, align 4
  %cmpEQ = icmp eq i32 %four1, 4
  %threePointFour2 = load double, double* %threePointFour, align 8
  %cmpEQ3 = fcmp oeq double %threePointFour2, 3.400000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %cmpEQ5 = icmp eq i1 %trueValue4, true
  %constructorReturnValue = call dereferenceable(1) %class.EqualsTest* @\\"binary_expression/equals_equals_equals.ts$EqualsTest$11constructor\\"()
  %constructorReturnValue6 = call dereferenceable(1) %class.EqualsTest* @\\"binary_expression/equals_equals_equals.ts$EqualsTest$11constructor\\"()
  %cmpEQ7 = icmp eq %class.EqualsTest* %constructorReturnValue, %constructorReturnValue6
  ret void
}

define linkonce_odr %class.EqualsTest* @\\"binary_expression/equals_equals_equals.ts$EqualsTest$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 1)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.EqualsTest*
  ret %class.EqualsTest* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`BinaryExpression equals-equals-equals-implicit-cast 1`] = `
"; ModuleID = 'binary-expression/equals-equals-equals-implicit-cast.ts'
source_filename = \\"binary-expression/equals-equals-equals-implicit-cast.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.TestEquals = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@TestEquals_name = private unnamed_addr constant [11 x i8] c\\"TestEquals\\\\00\\"
@TestEquals_type_descriptor = private constant { [11 x i8]* } { [11 x i8]* @TestEquals_name }

define void @_equalsEqualsEqualsTokenImplicitCast() {
entry:
  %four = alloca i32, align 4
  store i32 4, i32* %four, align 4
  %four1 = load i32, i32* %four, align 4
  %four1AsNumber = sitofp i32 %four1 to double
  %cmpEQ = fcmp oeq double %four1AsNumber, 4.000000e+00
  %constructorReturnValue = call dereferenceable(1) %class.TestEquals* @\\"binary_expression/equals_equals_equals_implicit_cast.ts$TestEquals$11constructor\\"()
  %cmpEQ2 = icmp eq %class.TestEquals* %constructorReturnValue, null
  %constructorReturnValue3 = call dereferenceable(1) %class.TestEquals* @\\"binary_expression/equals_equals_equals_implicit_cast.ts$TestEquals$11constructor\\"()
  %cmpEQ4 = icmp eq %class.TestEquals* null, %constructorReturnValue3
  ret void
}

define linkonce_odr %class.TestEquals* @\\"binary_expression/equals_equals_equals_implicit_cast.ts$TestEquals$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 1)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.TestEquals*
  ret %class.TestEquals* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`BinaryExpression equals-equals-equals-no-implicit-cast-error 1`] = `
"__tests__/code-generation/cases/binary-expression/equals-equals-equals-no-implicit-cast-error.ts(5,20): error TS1000019: No implicit cast for the binary expressions operands (left: TestEqualsTypeOne, right: TestEqualsTypeTwo) exists. An explicit cast of either of the operands to the other's type is required.
"
`;

exports[`BinaryExpression exclamation-equals-equals 1`] = `
"; ModuleID = 'binary-expression/exclamation-equals-equals.ts'
source_filename = \\"binary-expression/exclamation-equals-equals.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.NotEqualsTest = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@NotEqualsTest_name = private unnamed_addr constant [14 x i8] c\\"NotEqualsTest\\\\00\\"
@NotEqualsTest_type_descriptor = private constant { [14 x i8]* } { [14 x i8]* @NotEqualsTest_name }

define void @_exclamationEqualsEqualsToken() {
entry:
  %trueValue = alloca i1, align 1
  %threePointFour = alloca double, align 8
  %four = alloca i32, align 4
  store i32 4, i32* %four, align 4
  store double 3.400000e+00, double* %threePointFour, align 8
  store i1 true, i1* %trueValue, align 1
  %four1 = load i32, i32* %four, align 4
  %cmpNE = icmp ne i32 %four1, 4
  %threePointFour2 = load double, double* %threePointFour, align 8
  %cmpNE3 = fcmp one double %threePointFour2, 3.400000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %cmpNE5 = icmp ne i1 %trueValue4, true
  %constructorReturnValue = call dereferenceable(1) %class.NotEqualsTest* @\\"binary_expression/exclamation_equals_equals.ts$NotEqualsTest$11constructor\\"()
  %constructorReturnValue6 = call dereferenceable(1) %class.NotEqualsTest* @\\"binary_expression/exclamation_equals_equals.ts$NotEqualsTest$11constructor\\"()
  %cmpNE7 = icmp ne %class.NotEqualsTest* %constructorReturnValue, %constructorReturnValue6
  ret void
}

define linkonce_odr %class.NotEqualsTest* @\\"binary_expression/exclamation_equals_equals.ts$NotEqualsTest$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 1)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.NotEqualsTest*
  ret %class.NotEqualsTest* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`BinaryExpression exclamation-equals-equals-implicit-cast 1`] = `
"; ModuleID = 'binary-expression/exclamation-equals-equals-implicit-cast.ts'
source_filename = \\"binary-expression/exclamation-equals-equals-implicit-cast.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.NotEqualsImplicitCast = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@NotEqualsImplicitCast_name = private unnamed_addr constant [22 x i8] c\\"NotEqualsImplicitCast\\\\00\\"
@NotEqualsImplicitCast_type_descriptor = private constant { [22 x i8]* } { [22 x i8]* @NotEqualsImplicitCast_name }

define void @_exclamationEqualsEqualsTokenImplicitCast() {
entry:
  %four = alloca i32, align 4
  store i32 4, i32* %four, align 4
  %four1 = load i32, i32* %four, align 4
  %four1AsNumber = sitofp i32 %four1 to double
  %cmpNE = fcmp one double %four1AsNumber, 4.000000e+00
  %constructorReturnValue = call dereferenceable(1) %class.NotEqualsImplicitCast* @\\"binary_expression/exclamation_equals_equals_implicit_cast.ts$NotEqualsImplicitCast$11constructor\\"()
  %cmpNE2 = icmp ne %class.NotEqualsImplicitCast* %constructorReturnValue, null
  %constructorReturnValue3 = call dereferenceable(1) %class.NotEqualsImplicitCast* @\\"binary_expression/exclamation_equals_equals_implicit_cast.ts$NotEqualsImplicitCast$11constructor\\"()
  %cmpNE4 = icmp ne %class.NotEqualsImplicitCast* null, %constructorReturnValue3
  ret void
}

define linkonce_odr %class.NotEqualsImplicitCast* @\\"binary_expression/exclamation_equals_equals_implicit_cast.ts$NotEqualsImplicitCast$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 1)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.NotEqualsImplicitCast*
  ret %class.NotEqualsImplicitCast* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`BinaryExpression exclamation-equals-equals-no-implicit-cast-error 1`] = `
"__tests__/code-generation/cases/binary-expression/exclamation-equals-equals-no-implicit-cast-error.ts(5,20): error TS1000019: No implicit cast for the binary expressions operands (left: TestNotEqualsTypeOne, right: TestNotEqualsTypeTwo) exists. An explicit cast of either of the operands to the other's type is required.
"
`;

exports[`BinaryExpression first-assignment 1`] = `
"; ModuleID = 'binary-expression/first-assignment.ts'
source_filename = \\"binary-expression/first-assignment.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.MyClass = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@MyClass_name = private unnamed_addr constant [8 x i8] c\\"MyClass\\\\00\\"
@MyClass_type_descriptor = private constant { [8 x i8]* } { [8 x i8]* @MyClass_name }

define void @_firstAssignment() {
entry:
  %objectOrUndefined = alloca %class.MyClass*, align 4
  %objectVar = alloca %class.MyClass*, align 4
  %numberVar = alloca double, align 8
  %intVar = alloca i32, align 4
  %booleanVar = alloca i1, align 1
  store i1 true, i1* %booleanVar, align 1
  store i32 23, i32* %intVar, align 4
  store double 2.323000e+01, double* %numberVar, align 8
  %constructorReturnValue = call dereferenceable(1) %class.MyClass* @\\"binary_expression/first_assignment.ts$MyClass$11constructor\\"()
  store %class.MyClass* %constructorReturnValue, %class.MyClass** %objectVar, align 4
  %constructorReturnValue1 = call dereferenceable(1) %class.MyClass* @\\"binary_expression/first_assignment.ts$MyClass$11constructor\\"()
  store %class.MyClass* %constructorReturnValue1, %class.MyClass** %objectOrUndefined, align 4
  store %class.MyClass* null, %class.MyClass** %objectOrUndefined, align 4
  ret void
}

define linkonce_odr %class.MyClass* @\\"binary_expression/first_assignment.ts$MyClass$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 1)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.MyClass*
  ret %class.MyClass* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`BinaryExpression greater-than 1`] = `
"; ModuleID = 'binary-expression/greater-than.ts'
source_filename = \\"binary-expression/greater-than.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_greaterThan() {
entry:
  %trueValue = alloca i1, align 1
  %twoDouble = alloca double, align 8
  %two = alloca i32, align 4
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %cmpGT = icmp sgt i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %cmpGT3 = fcmp ogt double %twoDouble2, 4.000000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %0 = zext i1 %trueValue4 to i32
  %cmpGT5 = icmp sgt i32 %0, 0
  ret void
}
"
`;

exports[`BinaryExpression greater-than-equals 1`] = `
"; ModuleID = 'binary-expression/greater-than-equals.ts'
source_filename = \\"binary-expression/greater-than-equals.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_greaterThanEquals() {
entry:
  %trueValue = alloca i1, align 1
  %twoDouble = alloca double, align 8
  %two = alloca i32, align 4
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %cmpGE = icmp sge i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %cmpGE3 = fcmp oge double %twoDouble2, 4.000000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %0 = zext i1 %trueValue4 to i32
  %cmpGE5 = icmp sge i32 %0, 0
  ret void
}
"
`;

exports[`BinaryExpression greater-than-equals-implicit-cast 1`] = `
"; ModuleID = 'binary-expression/greater-than-equals-implicit-cast.ts'
source_filename = \\"binary-expression/greater-than-equals-implicit-cast.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_greaterThanEqualsImplicitCast() {
entry:
  ret void
}
"
`;

exports[`BinaryExpression greater-than-greater-than 1`] = `
"; ModuleID = 'binary-expression/greater-than-greater-than.ts'
source_filename = \\"binary-expression/greater-than-greater-than.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_greaterThanGreaterThan() {
entry:
  %intValue = alloca i32, align 4
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %ashr = ashr i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  %intValue2 = load i32, i32* %intValue, align 4
  %ashr3 = ashr i32 %intValue2, 2
  ret void
}

; Function Attrs: alwaysinline readnone
declare i32 @toInt32d(double) #0

attributes #0 = { alwaysinline readnone }
"
`;

exports[`BinaryExpression greater-than-greater-than-greater 1`] = `
"; ModuleID = 'binary-expression/greater-than-greater-than-greater.ts'
source_filename = \\"binary-expression/greater-than-greater-than-greater.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_greaterThanGreaterThanGreaterThan() {
entry:
  %intValue = alloca i32, align 4
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %lshr = lshr i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  %intValue2 = load i32, i32* %intValue, align 4
  %lshr3 = lshr i32 %intValue2, 2
  ret void
}

; Function Attrs: alwaysinline readnone
declare i32 @toInt32d(double) #0

attributes #0 = { alwaysinline readnone }
"
`;

exports[`BinaryExpression greater-than-implicit-cast 1`] = `
"; ModuleID = 'binary-expression/greater-than-implicit-cast.ts'
source_filename = \\"binary-expression/greater-than-implicit-cast.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_greaterThanImplicitCast() {
entry:
  ret void
}
"
`;

exports[`BinaryExpression less-than 1`] = `
"; ModuleID = 'binary-expression/less-than.ts'
source_filename = \\"binary-expression/less-than.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_lessThan() {
entry:
  %trueValue = alloca i1, align 1
  %twoDouble = alloca double, align 8
  %two = alloca i32, align 4
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %cmpLT = icmp slt i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %cmpLT3 = fcmp olt double %twoDouble2, 4.000000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %0 = zext i1 %trueValue4 to i32
  %cmpLT5 = icmp slt i32 %0, 0
  ret void
}
"
`;

exports[`BinaryExpression less-than-equals 1`] = `
"; ModuleID = 'binary-expression/less-than-equals.ts'
source_filename = \\"binary-expression/less-than-equals.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_lessThanEquals() {
entry:
  %trueValue = alloca i1, align 1
  %twoDouble = alloca double, align 8
  %two = alloca i32, align 4
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  store i1 true, i1* %trueValue, align 1
  %two1 = load i32, i32* %two, align 4
  %cmpLE = icmp sle i32 %two1, 4
  %twoDouble2 = load double, double* %twoDouble, align 8
  %cmpLE3 = fcmp ole double %twoDouble2, 4.000000e+00
  %trueValue4 = load i1, i1* %trueValue, align 1
  %0 = zext i1 %trueValue4 to i32
  %cmpLE5 = icmp sle i32 %0, 0
  ret void
}
"
`;

exports[`BinaryExpression less-than-equals-implicit-cast 1`] = `
"; ModuleID = 'binary-expression/less-than-equals-implicit-cast.ts'
source_filename = \\"binary-expression/less-than-equals-implicit-cast.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_lessThanEqualsImplicitCast() {
entry:
  ret void
}
"
`;

exports[`BinaryExpression less-than-implicit-cast 1`] = `
"; ModuleID = 'binary-expression/less-than-implicit-cast.ts'
source_filename = \\"binary-expression/less-than-implicit-cast.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_lessThanImplicitCast() {
entry:
  ret void
}
"
`;

exports[`BinaryExpression less-than-less-than 1`] = `
"; ModuleID = 'binary-expression/less-than-less-than.ts'
source_filename = \\"binary-expression/less-than-less-than.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_lessThanLessThan() {
entry:
  %numberValue = alloca double, align 8
  %intValue = alloca i32, align 4
  %AsInt32 = call i32 @toInt32d(double 6.500000e+00)
  %AsInt321 = call i32 @toInt32d(double 4.200000e+00)
  %shl = shl i32 %AsInt32, %AsInt321
  store i32 3, i32* %intValue, align 4
  store double 3.400000e+00, double* %numberValue, align 8
  %intValue2 = load i32, i32* %intValue, align 4
  %shl3 = shl i32 %intValue2, 2
  ret void
}

; Function Attrs: alwaysinline readnone
declare i32 @toInt32d(double) #0

attributes #0 = { alwaysinline readnone }
"
`;

exports[`BinaryExpression minus 1`] = `
"; ModuleID = 'binary-expression/minus.ts'
source_filename = \\"binary-expression/minus.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_minus() {
entry:
  %twoDouble = alloca double, align 8
  %two = alloca i32, align 4
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  %two1 = load i32, i32* %two, align 4
  %sub = sub i32 4, %two1
  %twoDouble2 = load double, double* %twoDouble, align 8
  %fsub = fsub double 4.000000e+00, %twoDouble2
  %two3 = load i32, i32* %two, align 4
  %sub4 = sub i32 %two3, 2
  store i32 %sub4, i32* %two, align 4
  %twoDouble5 = load double, double* %twoDouble, align 8
  %fsub6 = fsub double %twoDouble5, 2.000000e+00
  store double %fsub6, double* %twoDouble, align 8
  ret void
}
"
`;

exports[`BinaryExpression minus-implicit-cast 1`] = `
"; ModuleID = 'binary-expression/minus-implicit-cast.ts'
source_filename = \\"binary-expression/minus-implicit-cast.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_minusImplicitCast() {
entry:
  ret void
}
"
`;

exports[`BinaryExpression percent 1`] = `
"; ModuleID = 'binary-expression/percent.ts'
source_filename = \\"binary-expression/percent.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_percent() {
entry:
  %sixDouble = alloca double, align 8
  %six = alloca i32, align 4
  store i32 6, i32* %six, align 4
  store double 6.000000e+00, double* %sixDouble, align 8
  %six1 = load i32, i32* %six, align 4
  %srem = srem i32 8, %six1
  %sixDouble2 = load double, double* %sixDouble, align 8
  %frem = frem double 8.000000e+00, %sixDouble2
  ret void
}
"
`;

exports[`BinaryExpression percent-implicit-cast 1`] = `
"; ModuleID = 'binary-expression/percent-implicit-cast.ts'
source_filename = \\"binary-expression/percent-implicit-cast.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_percentImplicitCast() {
entry:
  ret void
}
"
`;

exports[`BinaryExpression plus 1`] = `
"; ModuleID = 'binary-expression/plus.ts'
source_filename = \\"binary-expression/plus.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_plus() {
entry:
  %twoDouble = alloca double, align 8
  %two = alloca i32, align 4
  store i32 2, i32* %two, align 4
  store double 2.000000e+00, double* %twoDouble, align 8
  %two1 = load i32, i32* %two, align 4
  %add = add i32 4, %two1
  %twoDouble2 = load double, double* %twoDouble, align 8
  %fadd = fadd double 4.000000e+00, %twoDouble2
  %two3 = load i32, i32* %two, align 4
  %add4 = add i32 %two3, 2
  store i32 %add4, i32* %two, align 4
  %twoDouble5 = load double, double* %twoDouble, align 8
  %fadd6 = fadd double %twoDouble5, 2.000000e+00
  store double %fadd6, double* %twoDouble, align 8
  ret void
}
"
`;

exports[`BinaryExpression plus-implicit-cast 1`] = `
"; ModuleID = 'binary-expression/plus-implicit-cast.ts'
source_filename = \\"binary-expression/plus-implicit-cast.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_plusImplicitCast() {
entry:
  ret void
}
"
`;

exports[`BinaryExpression slash 1`] = `
"; ModuleID = 'binary-expression/slash.ts'
source_filename = \\"binary-expression/slash.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_slash() {
entry:
  %doubleProduct = alloca double, align 8
  %intProduct = alloca i32, align 4
  store i32 1, i32* %intProduct, align 4
  %intProduct1 = load i32, i32* %intProduct, align 4
  %sdiv = sdiv i32 %intProduct1, 2
  store i32 %sdiv, i32* %intProduct, align 4
  store double 0x3FF5555555555555, double* %doubleProduct, align 8
  %doubleProduct2 = load double, double* %doubleProduct, align 8
  %div = fdiv double %doubleProduct2, 1.500000e+00
  store double %div, double* %doubleProduct, align 8
  ret void
}
"
`;

exports[`BinaryExpression slash-implicit-cast 1`] = `
"; ModuleID = 'binary-expression/slash-implicit-cast.ts'
source_filename = \\"binary-expression/slash-implicit-cast.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_slashImplicitCast() {
entry:
  ret void
}
"
`;
