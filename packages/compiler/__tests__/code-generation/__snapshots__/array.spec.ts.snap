// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Array array-literal 1`] = `
"; ModuleID = 'array/array-literal.ts'
source_filename = \\"array/array-literal.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array = type { i32*, i32*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@items = private local_unnamed_addr constant [4 x i32] [i32 1, i32 2, i32 3, i32 4]

define %class.Array* @_arrayLiteral() {
entry:
  %items = alloca [4 x i32], align 4
  %empty = alloca %class.Array*, align 4
  %return = alloca %class.Array*, align 4
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32* null, i32 0)
  store %class.Array* %constructorReturnValue, %class.Array** %empty, align 4
  %items1 = getelementptr inbounds [4 x i32], [4 x i32]* %items, i32 0, i32 0
  %0 = bitcast [4 x i32]* %items to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* bitcast ([4 x i32]* @items to i8*), i32 16, i32 0, i1 false)
  %constructorReturnValue2 = call dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32* %items1, i32 4)
  store %class.Array* %constructorReturnValue2, %class.Array** %return, align 4
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return3 = load %class.Array*, %class.Array** %return, align 4
  ret %class.Array* %return3
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32*, i32) #0

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture writeonly, i8* nocapture readonly, i32, i32, i1) #1

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { argmemonly nounwind }
"
`;

exports[`Array array-literal-implicit-cast 1`] = `
"; ModuleID = 'array/array-literal-implicit-cast.ts'
source_filename = \\"array/array-literal-implicit-cast.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array = type { double*, double*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@items = private local_unnamed_addr constant [4 x double] [double 1.000000e+00, double 2.000000e+00, double 3.000000e+00, double 7.000000e+00]

define %class.Array* @_arrayLiteralWithImplicitCast() {
entry:
  %items = alloca [4 x double], align 8
  %return = alloca %class.Array*, align 4
  %items1 = getelementptr inbounds [4 x double], [4 x double]* %items, i32 0, i32 0
  %0 = bitcast [4 x double]* %items to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* bitcast ([4 x double]* @items to i8*), i32 32, i32 0, i1 false)
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayId_constructorPdu(double* %items1, i32 4)
  store %class.Array* %constructorReturnValue, %class.Array** %return, align 4
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return2 = load %class.Array*, %class.Array** %return, align 4
  ret %class.Array* %return2
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayId_constructorPdu(double*, i32) #0

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture writeonly, i8* nocapture readonly, i32, i32, i1) #1

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { argmemonly nounwind }
"
`;

exports[`Array assignment 1`] = `
"; ModuleID = 'array/assignment.ts'
source_filename = \\"array/assignment.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array = type { i32*, i32*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@items = private local_unnamed_addr constant [3 x i32] [i32 1, i32 2, i32 3]

define void @_arrayAssignment() {
entry:
  %value = alloca i32, align 4
  %other = alloca %class.Array*, align 4
  %items = alloca [3 x i32], align 4
  %array = alloca %class.Array*, align 4
  %items1 = getelementptr inbounds [3 x i32], [3 x i32]* %items, i32 0, i32 0
  %0 = bitcast [3 x i32]* %items to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* bitcast ([3 x i32]* @items to i8*), i32 12, i32 0, i1 false)
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32* %items1, i32 3)
  store %class.Array* %constructorReturnValue, %class.Array** %array, align 4
  %array2 = load %class.Array*, %class.Array** %array, align 4
  store %class.Array* %array2, %class.Array** %other, align 4
  %other3 = load %class.Array*, %class.Array** %other, align 4
  %\\"[i]\\" = call i32 @ArrayIi_geti(%class.Array* %other3, i32 2)
  store i32 %\\"[i]\\", i32* %value, align 4
  ret void
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32*, i32) #0

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture writeonly, i8* nocapture readonly, i32, i32, i1) #1

; Function Attrs: alwaysinline norecurse nounwind readonly
declare i32 @ArrayIi_geti(%class.Array* nocapture dereferenceable(12), i32) #2

; Function Attrs: alwaysinline
declare void @ArrayIi_setii(%class.Array* nocapture dereferenceable(12), i32, i32) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { argmemonly nounwind }
attributes #2 = { alwaysinline norecurse nounwind readonly }
"
`;

exports[`Array element-access 1`] = `
"; ModuleID = 'array/element-access.ts'
source_filename = \\"array/element-access.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array = type { i32*, i32*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@items = private local_unnamed_addr constant [5 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5]

define void @_arrayElementAccess() {
entry:
  %items = alloca [5 x i32], align 4
  %array = alloca %class.Array*, align 4
  %items1 = getelementptr inbounds [5 x i32], [5 x i32]* %items, i32 0, i32 0
  %0 = bitcast [5 x i32]* %items to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* bitcast ([5 x i32]* @items to i8*), i32 20, i32 0, i1 false)
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32* %items1, i32 5)
  store %class.Array* %constructorReturnValue, %class.Array** %array, align 4
  %array2 = load %class.Array*, %class.Array** %array, align 4
  %\\"[i]\\" = call i32 @ArrayIi_geti(%class.Array* %array2, i32 2)
  %mul = mul i32 %\\"[i]\\", 10
  %array3 = load %class.Array*, %class.Array** %array, align 4
  call void @ArrayIi_setii(%class.Array* %array3, i32 2, i32 %mul)
  ret void
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32*, i32) #0

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture writeonly, i8* nocapture readonly, i32, i32, i1) #1

; Function Attrs: alwaysinline norecurse nounwind readonly
declare i32 @ArrayIi_geti(%class.Array* nocapture dereferenceable(12), i32) #2

; Function Attrs: alwaysinline
declare void @ArrayIi_setii(%class.Array* nocapture dereferenceable(12), i32, i32) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { argmemonly nounwind }
attributes #2 = { alwaysinline norecurse nounwind readonly }
"
`;

exports[`Array element-access-with-number-error 1`] = `
"__tests__/code-generation/cases/array/element-access-with-number-error.ts(5,15): error TS1000022: Unsupported element access expression with indexer of type 'number'. Only element access expressions with an integer index are supported.
"
`;

exports[`Array fill 1`] = `
"; ModuleID = 'array/fill.ts'
source_filename = \\"array/fill.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array = type { double*, double*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_arrayFill() {
entry:
  %array = alloca %class.Array*, align 4
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayId_constructori(i32 100)
  store %class.Array* %constructorReturnValue, %class.Array** %array, align 4
  %array1 = load %class.Array*, %class.Array** %array, align 4
  %fillReturnValue = call dereferenceable(12) %class.Array* @ArrayId_filld(%class.Array* %array1, double 1.000000e+01)
  %array2 = load %class.Array*, %class.Array** %array, align 4
  %fillReturnValue3 = call dereferenceable(12) %class.Array* @ArrayId_filldi(%class.Array* %array2, double 1.000000e+01, i32 5)
  %array4 = load %class.Array*, %class.Array** %array, align 4
  %fillReturnValue5 = call dereferenceable(12) %class.Array* @ArrayId_filldii(%class.Array* %array4, double 1.000000e+01, i32 5, i32 50)
  ret void
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayId_constructori(i32) #0

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayId_filld(%class.Array* readonly dereferenceable(12), double) #0

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayId_filldi(%class.Array* readonly dereferenceable(12), double, i32) #0

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayId_filldii(%class.Array* readonly dereferenceable(12), double, i32, i32) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
"
`;

exports[`Array length 1`] = `
"; ModuleID = 'array/length.ts'
source_filename = \\"array/length.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array = type { double*, double*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object

define void @_arrayLength() {
entry:
  %i = alloca i32, align 4
  %array = alloca %class.Array*, align 4
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayId_constructorPdu(double* null, i32 0)
  store %class.Array* %constructorReturnValue, %class.Array** %array, align 4
  %array1 = load %class.Array*, %class.Array** %array, align 4
  call void @ArrayId_lengthi(%class.Array* %array1, i32 100)
  %array2 = load %class.Array*, %class.Array** %array, align 4
  %length = call i32 @ArrayId_length(%class.Array* %array2)
  store i32 %length, i32* %i, align 4
  ret void
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayId_constructorPdu(double*, i32) #0

; Function Attrs: alwaysinline nounwind readonly
declare i32 @ArrayId_length(%class.Array* nocapture readonly dereferenceable(12)) #1

; Function Attrs: alwaysinline
declare void @ArrayId_lengthi(%class.Array* dereferenceable(12), i32) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { alwaysinline nounwind readonly }
"
`;

exports[`Array new 1`] = `
"; ModuleID = 'array/new.ts'
source_filename = \\"array/new.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array.1 = type { double*, double*, i32 }
%class.Array = type { i8*, i8*, i32 }
%class.Array.0 = type { i32*, i32*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@items = private local_unnamed_addr constant [1 x i1] [i1 true]
@items.1 = private local_unnamed_addr constant [3 x double] [double 1.000000e+00, double 2.000000e+00, double 3.000000e+00]

define void @_arrayConstructorCase() {
entry:
  %items4 = alloca [3 x double], align 8
  %arrayWithElements = alloca %class.Array.1*, align 4
  %items = alloca [1 x i1], align 1
  %arrayWithElement = alloca %class.Array*, align 4
  %arrayOfSize = alloca %class.Array.0*, align 4
  %emptyArray = alloca %class.Array*, align 4
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayIb_constructorPbu(i1* null, i32 0)
  store %class.Array* %constructorReturnValue, %class.Array** %emptyArray, align 4
  %constructorReturnValue1 = call dereferenceable(12) %class.Array.0* @ArrayIi_constructori(i32 1000)
  store %class.Array.0* %constructorReturnValue1, %class.Array.0** %arrayOfSize, align 4
  %items2 = getelementptr inbounds [1 x i1], [1 x i1]* %items, i32 0, i32 0
  %0 = bitcast [1 x i1]* %items to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* bitcast ([1 x i1]* @items to i8*), i32 1, i32 0, i1 false)
  %constructorReturnValue3 = call dereferenceable(12) %class.Array* @ArrayIb_constructorPbu(i1* %items2, i32 1)
  store %class.Array* %constructorReturnValue3, %class.Array** %arrayWithElement, align 4
  %items5 = getelementptr inbounds [3 x double], [3 x double]* %items4, i32 0, i32 0
  %1 = bitcast [3 x double]* %items4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %1, i8* bitcast ([3 x double]* @items.1 to i8*), i32 24, i32 0, i1 false)
  %constructorReturnValue6 = call dereferenceable(12) %class.Array.1* @ArrayId_constructorPdu(double* %items5, i32 3)
  store %class.Array.1* %constructorReturnValue6, %class.Array.1** %arrayWithElements, align 4
  ret void
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIb_constructorPbu(i1*, i32) #0

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array.0* @ArrayIi_constructori(i32) #0

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture writeonly, i8* nocapture readonly, i32, i32, i1) #1

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array.1* @ArrayId_constructorPdu(double*, i32) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { argmemonly nounwind }
"
`;

exports[`Array pop 1`] = `
"; ModuleID = 'array/pop.ts'
source_filename = \\"array/pop.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array = type { i32*, i32*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@items = private local_unnamed_addr constant [2 x i32] [i32 1, i32 2]

define void @_arrayPop() {
entry:
  %end = alloca i32, align 4
  %items = alloca [2 x i32], align 4
  %array = alloca %class.Array*, align 4
  %items1 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 0
  %0 = bitcast [2 x i32]* %items to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* bitcast ([2 x i32]* @items to i8*), i32 8, i32 0, i1 false)
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32* %items1, i32 2)
  store %class.Array* %constructorReturnValue, %class.Array** %array, align 4
  %array2 = load %class.Array*, %class.Array** %array, align 4
  %popReturnValue = call i32 @ArrayIi_pop(%class.Array* %array2)
  store i32 %popReturnValue, i32* %end, align 4
  ret void
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32*, i32) #0

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture writeonly, i8* nocapture readonly, i32, i32, i1) #1

; Function Attrs: alwaysinline
declare i32 @ArrayIi_pop(%class.Array* readonly dereferenceable(12)) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { argmemonly nounwind }
"
`;

exports[`Array push 1`] = `
"; ModuleID = 'array/push.ts'
source_filename = \\"array/push.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array = type { i32*, i32*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@items = private local_unnamed_addr constant [2 x i32] [i32 1, i32 2]
@items.1 = private local_unnamed_addr constant [1 x i32] [i32 1]
@items.2 = private local_unnamed_addr constant [3 x i32] [i32 1, i32 2, i32 3]

define void @_arrayPush() {
entry:
  %items8 = alloca [3 x i32], align 4
  %newLength = alloca i32, align 4
  %items4 = alloca [1 x i32], align 4
  %items = alloca [2 x i32], align 4
  %array = alloca %class.Array*, align 4
  %items1 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 0
  %0 = bitcast [2 x i32]* %items to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* bitcast ([2 x i32]* @items to i8*), i32 8, i32 0, i1 false)
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32* %items1, i32 2)
  store %class.Array* %constructorReturnValue, %class.Array** %array, align 4
  %array2 = load %class.Array*, %class.Array** %array, align 4
  %pushReturnValue = call i32 @ArrayIi_pushPiu(%class.Array* %array2, i32* null, i32 0)
  %array3 = load %class.Array*, %class.Array** %array, align 4
  %items5 = getelementptr inbounds [1 x i32], [1 x i32]* %items4, i32 0, i32 0
  %1 = bitcast [1 x i32]* %items4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %1, i8* bitcast ([1 x i32]* @items.1 to i8*), i32 4, i32 0, i1 false)
  %pushReturnValue6 = call i32 @ArrayIi_pushPiu(%class.Array* %array3, i32* %items5, i32 1)
  %array7 = load %class.Array*, %class.Array** %array, align 4
  %items9 = getelementptr inbounds [3 x i32], [3 x i32]* %items8, i32 0, i32 0
  %2 = bitcast [3 x i32]* %items8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %2, i8* bitcast ([3 x i32]* @items.2 to i8*), i32 12, i32 0, i1 false)
  %pushReturnValue10 = call i32 @ArrayIi_pushPiu(%class.Array* %array7, i32* %items9, i32 3)
  store i32 %pushReturnValue10, i32* %newLength, align 4
  ret void
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32*, i32) #0

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture writeonly, i8* nocapture readonly, i32, i32, i1) #1

; Function Attrs: alwaysinline
declare i32 @ArrayIi_pushPiu(%class.Array* readonly dereferenceable(12), i32*, i32) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { argmemonly nounwind }
"
`;

exports[`Array shift 1`] = `
"; ModuleID = 'array/shift.ts'
source_filename = \\"array/shift.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array = type { i32*, i32*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@items = private local_unnamed_addr constant [2 x i32] [i32 1, i32 2]

define void @_arrayShift() {
entry:
  %front = alloca i32, align 4
  %items = alloca [2 x i32], align 4
  %array = alloca %class.Array*, align 4
  %items1 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 0
  %0 = bitcast [2 x i32]* %items to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* bitcast ([2 x i32]* @items to i8*), i32 8, i32 0, i1 false)
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32* %items1, i32 2)
  store %class.Array* %constructorReturnValue, %class.Array** %array, align 4
  %array2 = load %class.Array*, %class.Array** %array, align 4
  %shiftReturnValue = call i32 @ArrayIi_shift(%class.Array* %array2)
  store i32 %shiftReturnValue, i32* %front, align 4
  ret void
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32*, i32) #0

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture writeonly, i8* nocapture readonly, i32, i32, i1) #1

; Function Attrs: alwaysinline
declare i32 @ArrayIi_shift(%class.Array* readonly dereferenceable(12)) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { argmemonly nounwind }
"
`;

exports[`Array slice 1`] = `
"; ModuleID = 'array/slice.ts'
source_filename = \\"array/slice.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array = type { i32*, i32*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@items = private local_unnamed_addr constant [10 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10]

define void @_arraySlice() {
entry:
  %items = alloca [10 x i32], align 4
  %array = alloca %class.Array*, align 4
  %items1 = getelementptr inbounds [10 x i32], [10 x i32]* %items, i32 0, i32 0
  %0 = bitcast [10 x i32]* %items to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* bitcast ([10 x i32]* @items to i8*), i32 40, i32 0, i1 false)
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32* %items1, i32 10)
  store %class.Array* %constructorReturnValue, %class.Array** %array, align 4
  %array2 = load %class.Array*, %class.Array** %array, align 4
  %sliceReturnValue = call dereferenceable(12) %class.Array* @ArrayIi_slice(%class.Array* %array2)
  %array3 = load %class.Array*, %class.Array** %array, align 4
  %sliceReturnValue4 = call dereferenceable(12) %class.Array* @ArrayIi_slicei(%class.Array* %array3, i32 4)
  %array5 = load %class.Array*, %class.Array** %array, align 4
  %sliceReturnValue6 = call dereferenceable(12) %class.Array* @ArrayIi_sliceii(%class.Array* %array5, i32 4, i32 8)
  ret void
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32*, i32) #0

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture writeonly, i8* nocapture readonly, i32, i32, i1) #1

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_slice(%class.Array* readonly dereferenceable(12)) #0

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_slicei(%class.Array* readonly dereferenceable(12), i32) #0

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_sliceii(%class.Array* readonly dereferenceable(12), i32, i32) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { argmemonly nounwind }
"
`;

exports[`Array splice 1`] = `
"; ModuleID = 'array/splice.ts'
source_filename = \\"array/splice.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array = type { i32*, i32*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@items = private local_unnamed_addr constant [10 x i32] [i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10]
@items.1 = private local_unnamed_addr constant [4 x i32] [i32 11, i32 12, i32 13, i32 14]

define void @_arraySplice() {
entry:
  %items6 = alloca [4 x i32], align 4
  %items = alloca [10 x i32], align 4
  %array = alloca %class.Array*, align 4
  %items1 = getelementptr inbounds [10 x i32], [10 x i32]* %items, i32 0, i32 0
  %0 = bitcast [10 x i32]* %items to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* bitcast ([10 x i32]* @items to i8*), i32 40, i32 0, i1 false)
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32* %items1, i32 10)
  store %class.Array* %constructorReturnValue, %class.Array** %array, align 4
  %array2 = load %class.Array*, %class.Array** %array, align 4
  %spliceReturnValue = call dereferenceable(12) %class.Array* @ArrayIi_spliceii(%class.Array* %array2, i32 5, i32 2)
  %array3 = load %class.Array*, %class.Array** %array, align 4
  %spliceReturnValue4 = call dereferenceable(12) %class.Array* @ArrayIi_splicei(%class.Array* %array3, i32 4)
  %array5 = load %class.Array*, %class.Array** %array, align 4
  %items7 = getelementptr inbounds [4 x i32], [4 x i32]* %items6, i32 0, i32 0
  %1 = bitcast [4 x i32]* %items6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %1, i8* bitcast ([4 x i32]* @items.1 to i8*), i32 16, i32 0, i1 false)
  %spliceReturnValue8 = call dereferenceable(12) %class.Array* @ArrayIi_spliceiiPiu(%class.Array* %array5, i32 2, i32 2, i32* %items7, i32 4)
  ret void
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32*, i32) #0

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture writeonly, i8* nocapture readonly, i32, i32, i1) #1

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_spliceii(%class.Array* readonly dereferenceable(12), i32, i32) #0

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_splicei(%class.Array* readonly dereferenceable(12), i32) #0

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_spliceiiPiu(%class.Array* readonly dereferenceable(12), i32, i32, i32*, i32) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { argmemonly nounwind }
"
`;

exports[`Array unshift 1`] = `
"; ModuleID = 'array/unshift.ts'
source_filename = \\"array/unshift.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Array = type { i32*, i32*, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@items = private local_unnamed_addr constant [2 x i32] [i32 1, i32 2]
@items.1 = private local_unnamed_addr constant [1 x i32] [i32 1]
@items.2 = private local_unnamed_addr constant [3 x i32] [i32 1, i32 2, i32 3]

define void @_arrayUnshift() {
entry:
  %items8 = alloca [3 x i32], align 4
  %newLength = alloca i32, align 4
  %items4 = alloca [1 x i32], align 4
  %items = alloca [2 x i32], align 4
  %array = alloca %class.Array*, align 4
  %items1 = getelementptr inbounds [2 x i32], [2 x i32]* %items, i32 0, i32 0
  %0 = bitcast [2 x i32]* %items to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* bitcast ([2 x i32]* @items to i8*), i32 8, i32 0, i1 false)
  %constructorReturnValue = call dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32* %items1, i32 2)
  store %class.Array* %constructorReturnValue, %class.Array** %array, align 4
  %array2 = load %class.Array*, %class.Array** %array, align 4
  %unshiftReturnValue = call i32 @ArrayIi_unshiftPiu(%class.Array* %array2, i32* null, i32 0)
  %array3 = load %class.Array*, %class.Array** %array, align 4
  %items5 = getelementptr inbounds [1 x i32], [1 x i32]* %items4, i32 0, i32 0
  %1 = bitcast [1 x i32]* %items4 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %1, i8* bitcast ([1 x i32]* @items.1 to i8*), i32 4, i32 0, i1 false)
  %unshiftReturnValue6 = call i32 @ArrayIi_unshiftPiu(%class.Array* %array3, i32* %items5, i32 1)
  %array7 = load %class.Array*, %class.Array** %array, align 4
  %items9 = getelementptr inbounds [3 x i32], [3 x i32]* %items8, i32 0, i32 0
  %2 = bitcast [3 x i32]* %items8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %2, i8* bitcast ([3 x i32]* @items.2 to i8*), i32 12, i32 0, i1 false)
  %unshiftReturnValue10 = call i32 @ArrayIi_unshiftPiu(%class.Array* %array7, i32* %items9, i32 3)
  store i32 %unshiftReturnValue10, i32* %newLength, align 4
  ret void
}

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIi_constructorPiu(i32*, i32) #0

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture writeonly, i8* nocapture readonly, i32, i32, i1) #1

; Function Attrs: alwaysinline
declare i32 @ArrayIi_unshiftPiu(%class.Array* readonly dereferenceable(12), i32*, i32) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { argmemonly nounwind }
"
`;

exports[`Array unsuppported-method-error 1`] = `
"__tests__/code-generation/cases/array/unsuppported-method-error.ts(5,11): error TS100001: The property 'indexOf' of the built in object 'Array' is not supported.
"
`;
