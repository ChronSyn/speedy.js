// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Classes array-with-objects-literal 1`] = `
"; ModuleID = 'classes/array-with-objects-literal.ts'
source_filename = \\"classes/array-with-objects-literal.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Point = type { double, double }
%class.Array = type { i8**, i8**, i32 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@Point_name = private unnamed_addr constant [6 x i8] c\\"Point\\\\00\\"
@Point_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Point_name }

define double @_arrayWithObjectLiterals() {
entry:
  %items = alloca [3 x %class.Point*], align 4
  %array = alloca %class.Array*, align 4
  %return = alloca double, align 8
  %constructorReturnValue = call dereferenceable(16) %class.Point* @\\"classes/array_with_objects_literal.ts$$Point$11constructordd\\"(double 1.000000e+00, double 2.000000e+00)
  %constructorReturnValue1 = call dereferenceable(16) %class.Point* @\\"classes/array_with_objects_literal.ts$$Point$11constructordd\\"(double 3.000000e+00, double 4.000000e+00)
  %constructorReturnValue2 = call dereferenceable(16) %class.Point* @\\"classes/array_with_objects_literal.ts$$Point$11constructordd\\"(double 5.000000e+00, double 6.000000e+00)
  %items3 = getelementptr inbounds [3 x %class.Point*], [3 x %class.Point*]* %items, i32 0, i32 0
  %0 = getelementptr inbounds [3 x %class.Point*], [3 x %class.Point*]* %items, i32 0, i32 0
  store %class.Point* %constructorReturnValue, %class.Point** %0, align 4
  %1 = getelementptr inbounds [3 x %class.Point*], [3 x %class.Point*]* %items, i32 0, i32 1
  store %class.Point* %constructorReturnValue1, %class.Point** %1, align 4
  %2 = getelementptr inbounds [3 x %class.Point*], [3 x %class.Point*]* %items, i32 0, i32 2
  store %class.Point* %constructorReturnValue2, %class.Point** %2, align 4
  %constructorReturnValue4 = call dereferenceable(12) %class.Array* @ArrayIPv_constructorPPvu(%class.Point** %items3, i32 3)
  store %class.Array* %constructorReturnValue4, %class.Array** %array, align 4
  %array5 = load %class.Array*, %class.Array** %array, align 4
  %\\"[i]\\" = call %class.Point* @ArrayIPv_geti(%class.Array* %array5, i32 0)
  %\\"&x\\" = getelementptr inbounds %class.Point, %class.Point* %\\"[i]\\", i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  store double %x, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return6 = load double, double* %return, align 8
  ret double %return6
}

define linkonce_odr %class.Point* @\\"classes/array_with_objects_literal.ts$$Point$11constructordd\\"(double %x, double %y) {
entry:
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.Point*
  %\\"&x\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  store double %x, double* %x.addr, align 8
  store double %y, double* %y.addr, align 8
  %x.addr1 = load double, double* %x.addr, align 8
  %\\"&x2\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 0
  store double %x.addr1, double* %\\"&x2\\", align 8
  %y.addr3 = load double, double* %y.addr, align 8
  %\\"&y4\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 1
  store double %y.addr3, double* %\\"&y4\\", align 8
  ret %class.Point* %this
}

declare i8* @malloc(i32)

; Function Attrs: alwaysinline
declare dereferenceable(12) %class.Array* @ArrayIPv_constructorPPvu(%class.Point**, i32) #0

; Function Attrs: alwaysinline norecurse nounwind readonly
declare %class.Point* @ArrayIPv_geti(%class.Array* nocapture dereferenceable(12), i32) #1

; Function Attrs: alwaysinline
declare void @ArrayIPv_setiPv(%class.Array* nocapture dereferenceable(12), i32, %class.Point*) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline }
attributes #1 = { alwaysinline norecurse nounwind readonly }
"
`;

exports[`Classes class-inheritance-error 1`] = `
"__tests__/code-generation/cases/classes/class-inheritance-error.ts(3,2): error TS1000032: Class inheritance is not yet supported.
"
`;

exports[`Classes class-only-with-attributes 1`] = `
"; ModuleID = 'classes/class-only-with-attributes.ts'
source_filename = \\"classes/class-only-with-attributes.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.ClassOnlyWithAttributes = type { double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@ClassOnlyWithAttributes_name = private unnamed_addr constant [24 x i8] c\\"ClassOnlyWithAttributes\\\\00\\"
@ClassOnlyWithAttributes_type_descriptor = private constant { [24 x i8]* } { [24 x i8]* @ClassOnlyWithAttributes_name }

define double @_classOnlyWithAttributes() {
entry:
  %instance = alloca %class.ClassOnlyWithAttributes*, align 4
  %return = alloca double, align 8
  %constructorReturnValue = call dereferenceable(16) %class.ClassOnlyWithAttributes* @\\"classes/class_only_with_attributes.ts$$ClassOnlyWithAttributes$11constructor\\"()
  store %class.ClassOnlyWithAttributes* %constructorReturnValue, %class.ClassOnlyWithAttributes** %instance, align 4
  %instance1 = load %class.ClassOnlyWithAttributes*, %class.ClassOnlyWithAttributes** %instance, align 4
  %\\"&x\\" = getelementptr inbounds %class.ClassOnlyWithAttributes, %class.ClassOnlyWithAttributes* %instance1, i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  %instance2 = load %class.ClassOnlyWithAttributes*, %class.ClassOnlyWithAttributes** %instance, align 4
  %\\"&y\\" = getelementptr inbounds %class.ClassOnlyWithAttributes, %class.ClassOnlyWithAttributes* %instance2, i32 0, i32 1
  %y = load double, double* %\\"&y\\", align 8
  %fadd = fadd double %x, %y
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return3 = load double, double* %return, align 8
  ret double %return3
}

define linkonce_odr %class.ClassOnlyWithAttributes* @\\"classes/class_only_with_attributes.ts$$ClassOnlyWithAttributes$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.ClassOnlyWithAttributes*
  %\\"&x\\" = getelementptr inbounds %class.ClassOnlyWithAttributes, %class.ClassOnlyWithAttributes* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.ClassOnlyWithAttributes, %class.ClassOnlyWithAttributes* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  ret %class.ClassOnlyWithAttributes* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`Classes class-only-with-methods 1`] = `
"; ModuleID = 'classes/class-only-with-methods.ts'
source_filename = \\"classes/class-only-with-methods.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.ClassOnlyWithMethods = type { i1 }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@ClassOnlyWithMethods_name = private unnamed_addr constant [21 x i8] c\\"ClassOnlyWithMethods\\\\00\\"
@ClassOnlyWithMethods_type_descriptor = private constant { [21 x i8]* } { [21 x i8]* @ClassOnlyWithMethods_name }

define double @_classOnlyWithMethods(double %x, double %y) {
entry:
  %instance = alloca %class.ClassOnlyWithMethods*, align 4
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %return = alloca double, align 8
  store double %x, double* %x.addr, align 8
  store double %y, double* %y.addr, align 8
  %constructorReturnValue = call dereferenceable(1) %class.ClassOnlyWithMethods* @\\"classes/class_only_with_methods.ts$$ClassOnlyWithMethods$11constructor\\"()
  store %class.ClassOnlyWithMethods* %constructorReturnValue, %class.ClassOnlyWithMethods** %instance, align 4
  %x.addr1 = load double, double* %x.addr, align 8
  %y.addr2 = load double, double* %y.addr, align 8
  %instance3 = load %class.ClassOnlyWithMethods*, %class.ClassOnlyWithMethods** %instance, align 4
  %addReturnValue = call double @\\"classes/class_only_with_methods.ts$$ClassOnlyWithMethods$3adddd\\"(%class.ClassOnlyWithMethods* %instance3, double %x.addr1, double %y.addr2)
  store double %addReturnValue, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return4 = load double, double* %return, align 8
  ret double %return4
}

define linkonce_odr %class.ClassOnlyWithMethods* @\\"classes/class_only_with_methods.ts$$ClassOnlyWithMethods$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 1)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.ClassOnlyWithMethods*
  ret %class.ClassOnlyWithMethods* %this
}

declare i8* @malloc(i32)

define linkonce_odr hidden double @\\"classes/class_only_with_methods.ts$$ClassOnlyWithMethods$3adddd\\"(%class.ClassOnlyWithMethods* readonly dereferenceable(1) %this1, double %x, double %y) {
entry:
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %this = alloca %class.ClassOnlyWithMethods*, align 4
  %return = alloca double, align 8
  store %class.ClassOnlyWithMethods* %this1, %class.ClassOnlyWithMethods** %this, align 4
  store double %x, double* %x.addr, align 8
  store double %y, double* %y.addr, align 8
  %x.addr2 = load double, double* %x.addr, align 8
  %y.addr3 = load double, double* %y.addr, align 8
  %fadd = fadd double %x.addr2, %y.addr3
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return4 = load double, double* %return, align 8
  ret double %return4
}

declare void @speedyJsGc()
"
`;

exports[`Classes class-with-access-to-constructor-defined-fields 1`] = `
"; ModuleID = 'classes/class-with-access-to-constructor-defined-fields.ts'
source_filename = \\"classes/class-with-access-to-constructor-defined-fields.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.ClassWithAttributeInitializer = type { double, double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@ClassWithAttributeInitializer_name = private unnamed_addr constant [30 x i8] c\\"ClassWithAttributeInitializer\\\\00\\"
@ClassWithAttributeInitializer_type_descriptor = private constant { [30 x i8]* } { [30 x i8]* @ClassWithAttributeInitializer_name }

define double @_classWithConstructor() {
entry:
  %instance = alloca %class.ClassWithAttributeInitializer*, align 4
  %return = alloca double, align 8
  %constructorReturnValue = call dereferenceable(24) %class.ClassWithAttributeInitializer* @\\"classes/class_with_access_to_constructor_defined_fields.ts$$ClassWithAttributeInitializer$11constructordd\\"(double 1.000000e+01, double 1.500000e+01)
  store %class.ClassWithAttributeInitializer* %constructorReturnValue, %class.ClassWithAttributeInitializer** %instance, align 4
  %instance1 = load %class.ClassWithAttributeInitializer*, %class.ClassWithAttributeInitializer** %instance, align 4
  %\\"&x\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %instance1, i32 0, i32 1
  %x = load double, double* %\\"&x\\", align 8
  %instance2 = load %class.ClassWithAttributeInitializer*, %class.ClassWithAttributeInitializer** %instance, align 4
  %\\"&y\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %instance2, i32 0, i32 2
  %y = load double, double* %\\"&y\\", align 8
  %fadd = fadd double %x, %y
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return3 = load double, double* %return, align 8
  ret double %return3
}

define linkonce_odr %class.ClassWithAttributeInitializer* @\\"classes/class_with_access_to_constructor_defined_fields.ts$$ClassWithAttributeInitializer$11constructordd\\"(double %x, double %y) {
entry:
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %\\"thisVoid*\\" = call i8* @malloc(i32 24)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.ClassWithAttributeInitializer*
  %\\"&distance\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&distance\\"
  %\\"&x\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 2
  store double 0.000000e+00, double* %\\"&y\\"
  store double %x, double* %x.addr, align 8
  %\\"&x1\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 1
  store double %x, double* %\\"&x1\\", align 8
  store double %y, double* %y.addr, align 8
  %\\"&y2\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 2
  store double %y, double* %\\"&y2\\", align 8
  %\\"&x3\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 1
  %x4 = load double, double* %\\"&x3\\", align 8
  %mathPtr = load %class.Math*, %class.Math** @Math_ptr, align 4
  %powReturnValue = call double @Math_powdd(%class.Math* %mathPtr, double %x4, double 2.000000e+00)
  %\\"&y5\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 2
  %y6 = load double, double* %\\"&y5\\", align 8
  %mathPtr7 = load %class.Math*, %class.Math** @Math_ptr, align 4
  %powReturnValue8 = call double @Math_powdd(%class.Math* %mathPtr7, double %y6, double 2.000000e+00)
  %fadd = fadd double %powReturnValue, %powReturnValue8
  %mathPtr9 = load %class.Math*, %class.Math** @Math_ptr, align 4
  %sqrtReturnValue = call double @Math_sqrtd(%class.Math* %mathPtr9, double %fadd)
  %\\"&distance10\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 0
  store double %sqrtReturnValue, double* %\\"&distance10\\", align 8
  ret %class.ClassWithAttributeInitializer* %this
}

declare i8* @malloc(i32)

; Function Attrs: alwaysinline nounwind readnone
declare double @Math_powdd(%class.Math* readonly dereferenceable(1), double, double) #0

; Function Attrs: alwaysinline nounwind readnone
declare double @Math_sqrtd(%class.Math* readonly dereferenceable(1), double) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline nounwind readnone }
"
`;

exports[`Classes class-with-attribute-defined-in-constructor 1`] = `
"; ModuleID = 'classes/class-with-attribute-defined-in-constructor.ts'
source_filename = \\"classes/class-with-attribute-defined-in-constructor.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.ClassWithAttributeInitializer = type { double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@ClassWithAttributeInitializer_name = private unnamed_addr constant [30 x i8] c\\"ClassWithAttributeInitializer\\\\00\\"
@ClassWithAttributeInitializer_type_descriptor = private constant { [30 x i8]* } { [30 x i8]* @ClassWithAttributeInitializer_name }

define double @_classWithConstructor() {
entry:
  %instance = alloca %class.ClassWithAttributeInitializer*, align 4
  %return = alloca double, align 8
  %constructorReturnValue = call dereferenceable(16) %class.ClassWithAttributeInitializer* @\\"classes/class_with_attribute_defined_in_constructor.ts$$ClassWithAttributeInitializer$11constructordd\\"(double 1.000000e+01, double 1.500000e+01)
  store %class.ClassWithAttributeInitializer* %constructorReturnValue, %class.ClassWithAttributeInitializer** %instance, align 4
  %instance1 = load %class.ClassWithAttributeInitializer*, %class.ClassWithAttributeInitializer** %instance, align 4
  %\\"&x\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %instance1, i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  %instance2 = load %class.ClassWithAttributeInitializer*, %class.ClassWithAttributeInitializer** %instance, align 4
  %\\"&y\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %instance2, i32 0, i32 1
  %y = load double, double* %\\"&y\\", align 8
  %fadd = fadd double %x, %y
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return3 = load double, double* %return, align 8
  ret double %return3
}

define linkonce_odr %class.ClassWithAttributeInitializer* @\\"classes/class_with_attribute_defined_in_constructor.ts$$ClassWithAttributeInitializer$11constructordd\\"(double %x, double %y) {
entry:
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.ClassWithAttributeInitializer*
  %\\"&x\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  store double %x, double* %x.addr, align 8
  %\\"&x1\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 0
  store double %x, double* %\\"&x1\\", align 8
  store double %y, double* %y.addr, align 8
  %\\"&y2\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 1
  store double %y, double* %\\"&y2\\", align 8
  ret %class.ClassWithAttributeInitializer* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`Classes class-with-attribute-initializer 1`] = `
"; ModuleID = 'classes/class-with-attribute-initializer.ts'
source_filename = \\"classes/class-with-attribute-initializer.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.ClassWithAttributeInitializer = type { double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@ClassWithAttributeInitializer_name = private unnamed_addr constant [30 x i8] c\\"ClassWithAttributeInitializer\\\\00\\"
@ClassWithAttributeInitializer_type_descriptor = private constant { [30 x i8]* } { [30 x i8]* @ClassWithAttributeInitializer_name }

define double @_classWithConstructor() {
entry:
  %instance = alloca %class.ClassWithAttributeInitializer*, align 4
  %return = alloca double, align 8
  %constructorReturnValue = call dereferenceable(16) %class.ClassWithAttributeInitializer* @\\"classes/class_with_attribute_initializer.ts$$ClassWithAttributeInitializer$11constructor\\"()
  store %class.ClassWithAttributeInitializer* %constructorReturnValue, %class.ClassWithAttributeInitializer** %instance, align 4
  %instance1 = load %class.ClassWithAttributeInitializer*, %class.ClassWithAttributeInitializer** %instance, align 4
  %\\"&x\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %instance1, i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  %instance2 = load %class.ClassWithAttributeInitializer*, %class.ClassWithAttributeInitializer** %instance, align 4
  %\\"&y\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %instance2, i32 0, i32 1
  %y = load double, double* %\\"&y\\", align 8
  %fadd = fadd double %x, %y
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return3 = load double, double* %return, align 8
  ret double %return3
}

define linkonce_odr %class.ClassWithAttributeInitializer* @\\"classes/class_with_attribute_initializer.ts$$ClassWithAttributeInitializer$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.ClassWithAttributeInitializer*
  %\\"&x\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 0
  store double 1.000000e+01, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.ClassWithAttributeInitializer, %class.ClassWithAttributeInitializer* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  ret %class.ClassWithAttributeInitializer* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`Classes class-with-constructor 1`] = `
"; ModuleID = 'classes/class-with-constructor.ts'
source_filename = \\"classes/class-with-constructor.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.ClassWithConstructor = type { double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@ClassWithConstructor_name = private unnamed_addr constant [21 x i8] c\\"ClassWithConstructor\\\\00\\"
@ClassWithConstructor_type_descriptor = private constant { [21 x i8]* } { [21 x i8]* @ClassWithConstructor_name }

define double @_classWithConstructor() {
entry:
  %instance = alloca %class.ClassWithConstructor*, align 4
  %return = alloca double, align 8
  %constructorReturnValue = call dereferenceable(16) %class.ClassWithConstructor* @\\"classes/class_with_constructor.ts$$ClassWithConstructor$11constructordd\\"(double 1.000000e+01, double 2.000000e+01)
  store %class.ClassWithConstructor* %constructorReturnValue, %class.ClassWithConstructor** %instance, align 4
  %instance1 = load %class.ClassWithConstructor*, %class.ClassWithConstructor** %instance, align 4
  %\\"&x\\" = getelementptr inbounds %class.ClassWithConstructor, %class.ClassWithConstructor* %instance1, i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  %instance2 = load %class.ClassWithConstructor*, %class.ClassWithConstructor** %instance, align 4
  %\\"&y\\" = getelementptr inbounds %class.ClassWithConstructor, %class.ClassWithConstructor* %instance2, i32 0, i32 1
  %y = load double, double* %\\"&y\\", align 8
  %fadd = fadd double %x, %y
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return3 = load double, double* %return, align 8
  ret double %return3
}

define linkonce_odr %class.ClassWithConstructor* @\\"classes/class_with_constructor.ts$$ClassWithConstructor$11constructordd\\"(double %x, double %y) {
entry:
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.ClassWithConstructor*
  %\\"&x\\" = getelementptr inbounds %class.ClassWithConstructor, %class.ClassWithConstructor* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.ClassWithConstructor, %class.ClassWithConstructor* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  store double %x, double* %x.addr, align 8
  store double %y, double* %y.addr, align 8
  %x.addr1 = load double, double* %x.addr, align 8
  %\\"&x2\\" = getelementptr inbounds %class.ClassWithConstructor, %class.ClassWithConstructor* %this, i32 0, i32 0
  store double %x.addr1, double* %\\"&x2\\", align 8
  %y.addr3 = load double, double* %y.addr, align 8
  %\\"&y4\\" = getelementptr inbounds %class.ClassWithConstructor, %class.ClassWithConstructor* %this, i32 0, i32 1
  store double %y.addr3, double* %\\"&y4\\", align 8
  ret %class.ClassWithConstructor* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`Classes class-with-methods 1`] = `
"; ModuleID = 'classes/class-with-methods.ts'
source_filename = \\"classes/class-with-methods.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Point = type { double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@Point_name = private unnamed_addr constant [6 x i8] c\\"Point\\\\00\\"
@Point_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Point_name }

define void @_classWithMethods(double %x, double %y) {
entry:
  %other = alloca %class.Point*, align 4
  %center = alloca %class.Point*, align 4
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  store double %x, double* %x.addr, align 8
  store double %y, double* %y.addr, align 8
  %constructorReturnValue = call dereferenceable(16) %class.Point* @\\"classes/class_with_methods.ts$$Point$11constructordd\\"(double 0.000000e+00, double 0.000000e+00)
  store %class.Point* %constructorReturnValue, %class.Point** %center, align 4
  %x.addr1 = load double, double* %x.addr, align 8
  %y.addr2 = load double, double* %y.addr, align 8
  %constructorReturnValue3 = call dereferenceable(16) %class.Point* @\\"classes/class_with_methods.ts$$Point$11constructordd\\"(double %x.addr1, double %y.addr2)
  store %class.Point* %constructorReturnValue3, %class.Point** %other, align 4
  %other4 = load %class.Point*, %class.Point** %other, align 4
  %center5 = load %class.Point*, %class.Point** %center, align 4
  %distanceToReturnValue = call double @\\"classes/class_with_methods.ts$$Point$10distanceTo5PointI\\"(%class.Point* %center5, %class.Point* %other4)
  ret void
}

define linkonce_odr %class.Point* @\\"classes/class_with_methods.ts$$Point$11constructordd\\"(double %x, double %y) {
entry:
  %y.addr = alloca double, align 8
  %x.addr = alloca double, align 8
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.Point*
  %\\"&x\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  store double %x, double* %x.addr, align 8
  store double %y, double* %y.addr, align 8
  %x.addr1 = load double, double* %x.addr, align 8
  %\\"&x2\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 0
  store double %x.addr1, double* %\\"&x2\\", align 8
  %y.addr3 = load double, double* %y.addr, align 8
  %\\"&y4\\" = getelementptr inbounds %class.Point, %class.Point* %this, i32 0, i32 1
  store double %y.addr3, double* %\\"&y4\\", align 8
  ret %class.Point* %this
}

declare i8* @malloc(i32)

define linkonce_odr hidden double @\\"classes/class_with_methods.ts$$Point$10distanceTo5PointI\\"(%class.Point* readonly dereferenceable(16) %this1, %class.Point* dereferenceable(16) %to) {
entry:
  %to.addr = alloca %class.Point*, align 4
  %this = alloca %class.Point*, align 4
  %return = alloca double, align 8
  store %class.Point* %this1, %class.Point** %this, align 4
  store %class.Point* %to, %class.Point** %to.addr, align 4
  %this2 = load %class.Point*, %class.Point** %this, align 4
  %\\"&x\\" = getelementptr inbounds %class.Point, %class.Point* %this2, i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  %to.addr3 = load %class.Point*, %class.Point** %to.addr, align 4
  %\\"&x4\\" = getelementptr inbounds %class.Point, %class.Point* %to.addr3, i32 0, i32 0
  %x5 = load double, double* %\\"&x4\\", align 8
  %fsub = fsub double %x, %x5
  %mathPtr = load %class.Math*, %class.Math** @Math_ptr, align 4
  %powReturnValue = call double @Math_powdd(%class.Math* %mathPtr, double %fsub, double 2.000000e+00)
  %this6 = load %class.Point*, %class.Point** %this, align 4
  %\\"&y\\" = getelementptr inbounds %class.Point, %class.Point* %this6, i32 0, i32 1
  %y = load double, double* %\\"&y\\", align 8
  %to.addr7 = load %class.Point*, %class.Point** %to.addr, align 4
  %\\"&y8\\" = getelementptr inbounds %class.Point, %class.Point* %to.addr7, i32 0, i32 1
  %y9 = load double, double* %\\"&y8\\", align 8
  %fsub10 = fsub double %y, %y9
  %mathPtr11 = load %class.Math*, %class.Math** @Math_ptr, align 4
  %powReturnValue12 = call double @Math_powdd(%class.Math* %mathPtr11, double %fsub10, double 2.000000e+00)
  %fadd = fadd double %powReturnValue, %powReturnValue12
  %mathPtr13 = load %class.Math*, %class.Math** @Math_ptr, align 4
  %sqrtReturnValue = call double @Math_sqrtd(%class.Math* %mathPtr13, double %fadd)
  store double %sqrtReturnValue, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return14 = load double, double* %return, align 8
  ret double %return14
}

; Function Attrs: alwaysinline nounwind readnone
declare double @Math_powdd(%class.Math* readonly dereferenceable(1), double, double) #0

; Function Attrs: alwaysinline nounwind readnone
declare double @Math_sqrtd(%class.Math* readonly dereferenceable(1), double) #0

declare void @speedyJsGc()

attributes #0 = { alwaysinline nounwind readnone }
"
`;

exports[`Classes class-with-static-method-error 1`] = `
"__tests__/code-generation/cases/classes/class-with-static-method-error.ts(17,11): error TS1000026: Static methods and properties are not yet supported.
"
`;

exports[`Classes generic-class-error 1`] = `
"__tests__/code-generation/cases/classes/generic-class-error.ts(1,1): error TS1000031: Generic classes are not yet supported.
"
`;

exports[`Classes potentially-undefined-object-reference 1`] = `
"; ModuleID = 'classes/potentially-undefined-object-reference.ts'
source_filename = \\"classes/potentially-undefined-object-reference.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.PotentiallyUndefinedClass = type { double, double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@PotentiallyUndefinedClass_name = private unnamed_addr constant [26 x i8] c\\"PotentiallyUndefinedClass\\\\00\\"
@PotentiallyUndefinedClass_type_descriptor = private constant { [26 x i8]* } { [26 x i8]* @PotentiallyUndefinedClass_name }

define double @_classOnlyWithAttributes(%class.PotentiallyUndefinedClass* %instance) {
entry:
  %instance.addr = alloca %class.PotentiallyUndefinedClass*, align 4
  %return = alloca double, align 8
  store %class.PotentiallyUndefinedClass* %instance, %class.PotentiallyUndefinedClass** %instance.addr, align 4
  %instance.addr1 = load %class.PotentiallyUndefinedClass*, %class.PotentiallyUndefinedClass** %instance.addr, align 4
  %cmpEQ = icmp eq %class.PotentiallyUndefinedClass* %instance.addr1, null
  br i1 %cmpEQ, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %constructorReturnValue = call dereferenceable(16) %class.PotentiallyUndefinedClass* @\\"classes/potentially_undefined_object_reference.ts$$PotentiallyUndefinedClass$11constructor\\"()
  store %class.PotentiallyUndefinedClass* %constructorReturnValue, %class.PotentiallyUndefinedClass** %instance.addr, align 4
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %instance.addr2 = load %class.PotentiallyUndefinedClass*, %class.PotentiallyUndefinedClass** %instance.addr, align 4
  %\\"&x\\" = getelementptr inbounds %class.PotentiallyUndefinedClass, %class.PotentiallyUndefinedClass* %instance.addr2, i32 0, i32 0
  %x = load double, double* %\\"&x\\", align 8
  %instance.addr3 = load %class.PotentiallyUndefinedClass*, %class.PotentiallyUndefinedClass** %instance.addr, align 4
  %\\"&y\\" = getelementptr inbounds %class.PotentiallyUndefinedClass, %class.PotentiallyUndefinedClass* %instance.addr3, i32 0, i32 1
  %y = load double, double* %\\"&y\\", align 8
  %fadd = fadd double %x, %y
  store double %fadd, double* %return, align 8
  br label %returnBlock

returnBlock:                                      ; preds = %if.end
  %return4 = load double, double* %return, align 8
  ret double %return4
}

define linkonce_odr %class.PotentiallyUndefinedClass* @\\"classes/potentially_undefined_object_reference.ts$$PotentiallyUndefinedClass$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 16)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.PotentiallyUndefinedClass*
  %\\"&x\\" = getelementptr inbounds %class.PotentiallyUndefinedClass, %class.PotentiallyUndefinedClass* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&x\\"
  %\\"&y\\" = getelementptr inbounds %class.PotentiallyUndefinedClass, %class.PotentiallyUndefinedClass* %this, i32 0, i32 1
  store double 0.000000e+00, double* %\\"&y\\"
  ret %class.PotentiallyUndefinedClass* %this
}

declare i8* @malloc(i32)

declare void @speedyJsGc()
"
`;

exports[`Classes returning-this 1`] = `
"; ModuleID = 'classes/returning-this.ts'
source_filename = \\"classes/returning-this.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.TestBuilder = type { double }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@TestBuilder_name = private unnamed_addr constant [12 x i8] c\\"TestBuilder\\\\00\\"
@TestBuilder_type_descriptor = private constant { [12 x i8]* } { [12 x i8]* @TestBuilder_name }

define %class.TestBuilder* @_createDefaultBuilder() {
entry:
  %return = alloca %class.TestBuilder*, align 4
  %constructorReturnValue = call dereferenceable(8) %class.TestBuilder* @\\"classes/returning_this.ts$$TestBuilder$11constructor\\"()
  %sizeReturnValue = call dereferenceable(8) %class.TestBuilder* @\\"classes/returning_this.ts$$TestBuilder$4sized\\"(%class.TestBuilder* %constructorReturnValue, double 4.000000e+00)
  store %class.TestBuilder* %sizeReturnValue, %class.TestBuilder** %return, align 4
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return1 = load %class.TestBuilder*, %class.TestBuilder** %return, align 4
  ret %class.TestBuilder* %return1
}

define linkonce_odr %class.TestBuilder* @\\"classes/returning_this.ts$$TestBuilder$11constructor\\"() {
entry:
  %\\"thisVoid*\\" = call i8* @malloc(i32 8)
  %this = bitcast i8* %\\"thisVoid*\\" to %class.TestBuilder*
  %\\"&_size\\" = getelementptr inbounds %class.TestBuilder, %class.TestBuilder* %this, i32 0, i32 0
  store double 0.000000e+00, double* %\\"&_size\\"
  ret %class.TestBuilder* %this
}

declare i8* @malloc(i32)

define linkonce_odr hidden dereferenceable(8) %class.TestBuilder* @\\"classes/returning_this.ts$$TestBuilder$4sized\\"(%class.TestBuilder* readonly dereferenceable(8) %this1, double %value) {
entry:
  %value.addr = alloca double, align 8
  %this = alloca %class.TestBuilder*, align 4
  %return = alloca %class.TestBuilder*, align 4
  store %class.TestBuilder* %this1, %class.TestBuilder** %this, align 4
  store double %value, double* %value.addr, align 8
  %value.addr2 = load double, double* %value.addr, align 8
  %this3 = load %class.TestBuilder*, %class.TestBuilder** %this, align 4
  %\\"&_size\\" = getelementptr inbounds %class.TestBuilder, %class.TestBuilder* %this3, i32 0, i32 0
  store double %value.addr2, double* %\\"&_size\\", align 8
  %this4 = load %class.TestBuilder*, %class.TestBuilder** %this, align 4
  store %class.TestBuilder* %this4, %class.TestBuilder** %return, align 4
  br label %returnBlock

returnBlock:                                      ; preds = %entry
  %return5 = load %class.TestBuilder*, %class.TestBuilder** %return, align 4
  ret %class.TestBuilder* %return5
}

declare void @speedyJsGc()
"
`;

exports[`Classes undefined-object-member 1`] = `
"; ModuleID = 'classes/undefined-object-member.ts'
source_filename = \\"classes/undefined-object-member.ts\\"
target datalayout = \\"e-m:e-p:32:32-i64:64-n32:64-S128\\"
target triple = \\"wasm32-unknown-unknown\\"

%class.Math = type { i1 }
%class.Node = type { double, %class.Node* }

@Array_name = private unnamed_addr constant [6 x i8] c\\"Array\\\\00\\"
@Array_type_descriptor = private constant { [6 x i8]* } { [6 x i8]* @Array_name }
@Math_name = private unnamed_addr constant [5 x i8] c\\"Math\\\\00\\"
@Math_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Math_name }
@Math_object = private constant %class.Math zeroinitializer
@Math_ptr = private constant %class.Math* @Math_object
@Node_name = private unnamed_addr constant [5 x i8] c\\"Node\\\\00\\"
@Node_type_descriptor = private constant { [5 x i8]* } { [5 x i8]* @Node_name }

define i32 @_length(%class.Node* %start) {
entry:
  %length = alloca i32, align 4
  %current = alloca %class.Node*, align 4
  %start.addr = alloca %class.Node*, align 4
  %return = alloca i32, align 4
  store %class.Node* %start, %class.Node** %start.addr, align 4
  %start.addr1 = load %class.Node*, %class.Node** %start.addr, align 4
  store %class.Node* %start.addr1, %class.Node** %current, align 4
  store i32 0, i32* %length, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %current2 = load %class.Node*, %class.Node** %current, align 4
  %cmpNE = icmp ne %class.Node* %current2, null
  br i1 %cmpNE, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %length3 = load i32, i32* %length, align 4
  %add = add i32 %length3, 1
  store i32 %add, i32* %length, align 4
  %current4 = load %class.Node*, %class.Node** %current, align 4
  %\\"&next\\" = getelementptr inbounds %class.Node, %class.Node* %current4, i32 0, i32 1
  %next = load %class.Node*, %class.Node** %\\"&next\\", align 4
  store %class.Node* %next, %class.Node** %current, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %length5 = load i32, i32* %length, align 4
  store i32 %length5, i32* %return, align 4
  br label %returnBlock

returnBlock:                                      ; preds = %while.end
  %return6 = load i32, i32* %return, align 4
  ret i32 %return6
}

define void @_truncate(%class.Node* %position) {
entry:
  %position.addr = alloca %class.Node*, align 4
  store %class.Node* %position, %class.Node** %position.addr, align 4
  %position.addr1 = load %class.Node*, %class.Node** %position.addr, align 4
  %\\"&next\\" = getelementptr inbounds %class.Node, %class.Node* %position.addr1, i32 0, i32 1
  store %class.Node* null, %class.Node** %\\"&next\\", align 4
  ret void
}
"
`;
