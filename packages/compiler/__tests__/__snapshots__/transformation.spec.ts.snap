// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Transformation casts the return value for boolean functions to a bool value 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * The code is inspired by https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
function __moduleLoader(wasmUri, options) {
    var PTR_SIZE = 4;
    var PTR_SHIFT = Math.log2(PTR_SIZE);
    function sizeOf(type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return 1;
            case \\"i32\\":
                return 4;
            case \\"double\\":
                return 8;
            default:
                return PTR_SIZE;
        }
    }
    function getHeapValue(ptr, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return heap8[ptr];
            case \\"i32\\":
                return heap32[ptr >> 2] | 0;
            case \\"double\\":
                return heap64[ptr >> 3];
            default:
                return heapPtr[ptr >> PTR_SHIFT] | 0;
        }
    }
    function setHeapValue(ptr, value, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                heap8[ptr] = value;
                break;
            case \\"i32\\":
                heap32[ptr >> 2] = value;
                break;
            case \\"double\\":
                heap64[ptr >> 3] = value;
                break;
            default:
                heapPtr[ptr >> PTR_SHIFT] = value;
        }
    }
    var heap8;
    var heap32;
    var heapPtr;
    var heap64;
    var malloc = function () { throw new Error(\\"malloc not defined\\"); };
    var free = function () { return void 0; };
    function updateHeap(buffer) {
        heap8 = new Int8Array(buffer);
        heap32 = heapPtr = new Int32Array(buffer);
        heap64 = new Float64Array(buffer);
    }
    /**
     * Computes the size of a not packed object
     */
    function computeObjectSize(type) {
        return type.fields.reduce(function (memo, field) {
            var fieldSize = sizeOf(field.type);
            return alignMemory(memo + fieldSize, fieldSize);
        }, 0);
    }
    function jsToWasm(jsValue, typeName, types, objectReferences) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            return jsValue;
        }
        if (jsValue === null) {
            throw new Error(\\"Undefined and null values are not supported\\");
        }
        if (typeof (jsValue) === \\"undefined\\") {
            return 0;
        }
        var ptr = objectReferences.get(jsValue);
        if (typeof (ptr) !== \\"undefined\\") {
            return ptr;
        }
        if (type.constructor === Array) {
            if (!Array.isArray(jsValue)) {
                throw new Error(\\"Expected argument of type Array\\");
            }
            ptr = RuntimeArray.from(jsValue, type.typeArguments[0], types, objectReferences).ptr;
        }
        else {
            // Object
            if (typeof (jsValue) !== \\"object\\") {
                throw new Error(\\"Expected argument of type object but was typeof \\" + typeof (jsValue) + \\".\\");
            }
            if (jsValue.constructor !== type.constructor) {
                throw new Error(\\"Expected object of type \\" + type.constructor + \\" but was \\" + jsValue.constructor + \\" (inheritance is not supported).\\");
            }
            var size = computeObjectSize(type);
            var objPtr = malloc(size);
            if (objPtr === 0) {
                throw new Error(\\"Failed to allocate object\\");
            }
            var offset = 0;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                offset = alignMemory(offset, fieldSize);
                setHeapValue(objPtr + offset, jsToWasm(jsValue[field.name], field.type, types, objectReferences), field.type);
                offset += fieldSize;
            }
            ptr = objPtr;
        }
        objectReferences.set(jsValue, ptr);
        return ptr;
    }
    function wasmToJs(wasmValue, typeName, types, returnedObjects) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            if (typeName === \\"i1\\") {
                return wasmValue !== 0;
            }
            return wasmValue;
        }
        var ptr = wasmValue;
        var objectReference = returnedObjects.get(ptr);
        if (typeof objectReference !== \\"undefined\\") {
            return objectReference;
        }
        if (ptr === 0) {
            return undefined;
        }
        else if (type.constructor === Array) {
            objectReference = new RuntimeArray(ptr, type.typeArguments[0]).toArray(types, returnedObjects);
        }
        else {
            // Object
            var obj = Object.create(type.constructor.prototype); // ensure it is an instance of the class
            var memoryOffset = wasmValue;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                memoryOffset = alignMemory(memoryOffset, fieldSize);
                obj[field.name] = wasmToJs(getHeapValue(memoryOffset, field.type), field.type, types, returnedObjects);
                memoryOffset += fieldSize;
            }
            objectReference = obj;
        }
        returnedObjects.set(ptr, objectReference);
        return objectReference;
    }
    var RuntimeArray = (function () {
        function RuntimeArray(ptr, elementType) {
            this.ptr = ptr;
            this.elementType = elementType;
        }
        /**
         * Allocates a Speedy.js array for the given JS array
         * @param native the js array
         * @param elementType the element type
         * @param types the reflection information of the used types
         * @param objectReferences map from JS to WASM pointers of already deserialized objects
         * @return {RuntimeArray} the Speedy.js Array
         */
        RuntimeArray.from = function (native, elementType, types, objectReferences) {
            // begin, back, capacity
            var size = PTR_SIZE * 2 + sizeOf(\\"i32\\");
            var arrayPtr = malloc(size);
            var elementSize = sizeOf(elementType);
            var elementsPtr = malloc(elementSize * native.length);
            if (arrayPtr === 0 || elementsPtr === 0) {
                throw new Error(\\"Failed to allocate array\\");
            }
            var begin = elementsPtr;
            var back = elementsPtr + (elementSize * native.length);
            heapPtr[arrayPtr >> PTR_SHIFT] = begin;
            heapPtr[(arrayPtr + PTR_SIZE) >> PTR_SHIFT] = back;
            heap32[(arrayPtr + 2 * PTR_SIZE) >> 2] = native.length | 0;
            switch (elementType) {
                case \\"i1\\":
                case \\"i8\\":
                    heap8.set(native, begin);
                    break;
                case \\"i32\\":
                    heap32.set(native, begin >> 2);
                    break;
                case \\"double\\":
                    heap64.set(native, begin >> 3);
                    break;
                default:
                    heapPtr.set(Int32Array.from(native, function (object) { return jsToWasm(object, elementType, types, objectReferences); }), begin >> PTR_SHIFT);
            }
            return new RuntimeArray(arrayPtr, elementType);
        };
        Object.defineProperty(RuntimeArray.prototype, \\"begin\\", {
            get: function () {
                return heapPtr[this.ptr >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RuntimeArray.prototype, \\"back\\", {
            get: function () {
                return heapPtr[(this.ptr + PTR_SIZE) >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Converts a Speedy.js array to a native JS array
         * @param types the reflection information of the object types
         * @param objectReferences map from WASM pointers to the deserialized JS objects
         * @return {Array} the native JS Array
         */
        RuntimeArray.prototype.toArray = function (types, objectReferences) {
            var _this = this;
            switch (this.elementType) {
                case \\"i1\\":
                    return Array.from(heap8.subarray(this.begin, this.back), function (value) { return value !== 0; }); // Elements need to be converted to bool
                case \\"i8\\":
                    return Array.from(heap8.subarray(this.begin, this.back));
                case \\"i32\\":
                    return Array.from(heap32.subarray(this.begin >> 2, this.back >> 2));
                case \\"double\\":
                    return Array.from(heap64.subarray(this.begin >> 3, this.back >> 3));
                default:
                    return Array.from(heapPtr.subarray(this.begin >> PTR_SHIFT, this.back >> PTR_SHIFT), function (objectPtr) { return wasmToJs(objectPtr, _this.elementType, types, objectReferences); });
            }
        };
        return RuntimeArray;
    }());
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    heap8 = new Int8Array(memory.buffer);
    heap32 = heapPtr = new Int32Array(memory.buffer);
    heap64 = new Float64Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    // the top of the heap
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    heap32[GLOBAL_BASE >> 2] = STACK_TOP;
    heap32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = heap32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            // tslint:disable-next-line:no-console
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        heap32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            updateHeap(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== \\"undefined\\" && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module.require;
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    __cxa_allocate_exception: function (size) {
                        return malloc(size);
                    },
                    __cxa_throw: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_find_matching_catch_2: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_free_exception: function (ptr) {
                        try {
                            return free(ptr);
                        }
                        catch (e) {
                            // tslint:disable-next-line:no-console
                            console.error(\\"exception during cxa_free_exception: \\" + e);
                        }
                    },
                    __resumeException: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_atexit: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    pow: Math.pow,
                    fmod: function (x, y) {
                        return x % y;
                    },
                    abort: function (what) {
                        // tslint:disable-next-line:no-console
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    invoke_ii: function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    invoke_iii: function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    invoke_iiii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    invoke_iiiii: function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    invoke_viii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    sbrk: sbrk
                }
            });
        }).then(function (result) {
            instance = result.instance;
            free = instance.exports.free || free;
            malloc = instance.exports.malloc || malloc;
            return instance;
        });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    loader.toWASM = function (jsObject, objectTypeName, types, objectReferences) {
        return jsToWasm(jsObject, objectTypeName, types, objectReferences);
    };
    loader.toJSObject = function (objectPointer, objectTypeName, types) {
        return wasmToJs(objectPointer, objectTypeName, types, new Map());
    };
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
var loadWasmModule_1 = __moduleLoader(\\"./istruthy.wasm\\", { \\"totalStack\\": 532480, \\"initialMemory\\": 16777216, \\"globalBase\\": 8, \\"staticBump\\": 8, \\"exposeGc\\": false });
function isTruthy(value) { return loadWasmModule_1().then(function instanceLoaded(instance_1) { var types_1 = { \\"i1\\": { \\"primitive\\": true, \\"fields\\": [], \\"constructor\\": undefined, \\"typeArguments\\": [] }, \\"i32\\": { \\"primitive\\": true, \\"fields\\": [], \\"constructor\\": undefined, \\"typeArguments\\": [] } }; var result_1 = instance_1.exports._isTruthy(value) === 1; loadWasmModule_1.gc(); return result_1; }); }
"
`;

exports[`Transformation converts Array and Objects to WASM arrays and Objects 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * The code is inspired by https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
function __moduleLoader(wasmUri, options) {
    var PTR_SIZE = 4;
    var PTR_SHIFT = Math.log2(PTR_SIZE);
    function sizeOf(type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return 1;
            case \\"i32\\":
                return 4;
            case \\"double\\":
                return 8;
            default:
                return PTR_SIZE;
        }
    }
    function getHeapValue(ptr, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return heap8[ptr];
            case \\"i32\\":
                return heap32[ptr >> 2] | 0;
            case \\"double\\":
                return heap64[ptr >> 3];
            default:
                return heapPtr[ptr >> PTR_SHIFT] | 0;
        }
    }
    function setHeapValue(ptr, value, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                heap8[ptr] = value;
                break;
            case \\"i32\\":
                heap32[ptr >> 2] = value;
                break;
            case \\"double\\":
                heap64[ptr >> 3] = value;
                break;
            default:
                heapPtr[ptr >> PTR_SHIFT] = value;
        }
    }
    var heap8;
    var heap32;
    var heapPtr;
    var heap64;
    var malloc = function () { throw new Error(\\"malloc not defined\\"); };
    var free = function () { return void 0; };
    function updateHeap(buffer) {
        heap8 = new Int8Array(buffer);
        heap32 = heapPtr = new Int32Array(buffer);
        heap64 = new Float64Array(buffer);
    }
    /**
     * Computes the size of a not packed object
     */
    function computeObjectSize(type) {
        return type.fields.reduce(function (memo, field) {
            var fieldSize = sizeOf(field.type);
            return alignMemory(memo + fieldSize, fieldSize);
        }, 0);
    }
    function jsToWasm(jsValue, typeName, types, objectReferences) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            return jsValue;
        }
        if (jsValue === null) {
            throw new Error(\\"Undefined and null values are not supported\\");
        }
        if (typeof (jsValue) === \\"undefined\\") {
            return 0;
        }
        var ptr = objectReferences.get(jsValue);
        if (typeof (ptr) !== \\"undefined\\") {
            return ptr;
        }
        if (type.constructor === Array) {
            if (!Array.isArray(jsValue)) {
                throw new Error(\\"Expected argument of type Array\\");
            }
            ptr = RuntimeArray.from(jsValue, type.typeArguments[0], types, objectReferences).ptr;
        }
        else {
            // Object
            if (typeof (jsValue) !== \\"object\\") {
                throw new Error(\\"Expected argument of type object but was typeof \\" + typeof (jsValue) + \\".\\");
            }
            if (jsValue.constructor !== type.constructor) {
                throw new Error(\\"Expected object of type \\" + type.constructor + \\" but was \\" + jsValue.constructor + \\" (inheritance is not supported).\\");
            }
            var size = computeObjectSize(type);
            var objPtr = malloc(size);
            if (objPtr === 0) {
                throw new Error(\\"Failed to allocate object\\");
            }
            var offset = 0;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                offset = alignMemory(offset, fieldSize);
                setHeapValue(objPtr + offset, jsToWasm(jsValue[field.name], field.type, types, objectReferences), field.type);
                offset += fieldSize;
            }
            ptr = objPtr;
        }
        objectReferences.set(jsValue, ptr);
        return ptr;
    }
    function wasmToJs(wasmValue, typeName, types, returnedObjects) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            if (typeName === \\"i1\\") {
                return wasmValue !== 0;
            }
            return wasmValue;
        }
        var ptr = wasmValue;
        var objectReference = returnedObjects.get(ptr);
        if (typeof objectReference !== \\"undefined\\") {
            return objectReference;
        }
        if (ptr === 0) {
            return undefined;
        }
        else if (type.constructor === Array) {
            objectReference = new RuntimeArray(ptr, type.typeArguments[0]).toArray(types, returnedObjects);
        }
        else {
            // Object
            var obj = Object.create(type.constructor.prototype); // ensure it is an instance of the class
            var memoryOffset = wasmValue;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                memoryOffset = alignMemory(memoryOffset, fieldSize);
                obj[field.name] = wasmToJs(getHeapValue(memoryOffset, field.type), field.type, types, returnedObjects);
                memoryOffset += fieldSize;
            }
            objectReference = obj;
        }
        returnedObjects.set(ptr, objectReference);
        return objectReference;
    }
    var RuntimeArray = (function () {
        function RuntimeArray(ptr, elementType) {
            this.ptr = ptr;
            this.elementType = elementType;
        }
        /**
         * Allocates a Speedy.js array for the given JS array
         * @param native the js array
         * @param elementType the element type
         * @param types the reflection information of the used types
         * @param objectReferences map from JS to WASM pointers of already deserialized objects
         * @return {RuntimeArray} the Speedy.js Array
         */
        RuntimeArray.from = function (native, elementType, types, objectReferences) {
            // begin, back, capacity
            var size = PTR_SIZE * 2 + sizeOf(\\"i32\\");
            var arrayPtr = malloc(size);
            var elementSize = sizeOf(elementType);
            var elementsPtr = malloc(elementSize * native.length);
            if (arrayPtr === 0 || elementsPtr === 0) {
                throw new Error(\\"Failed to allocate array\\");
            }
            var begin = elementsPtr;
            var back = elementsPtr + (elementSize * native.length);
            heapPtr[arrayPtr >> PTR_SHIFT] = begin;
            heapPtr[(arrayPtr + PTR_SIZE) >> PTR_SHIFT] = back;
            heap32[(arrayPtr + 2 * PTR_SIZE) >> 2] = native.length | 0;
            switch (elementType) {
                case \\"i1\\":
                case \\"i8\\":
                    heap8.set(native, begin);
                    break;
                case \\"i32\\":
                    heap32.set(native, begin >> 2);
                    break;
                case \\"double\\":
                    heap64.set(native, begin >> 3);
                    break;
                default:
                    heapPtr.set(Int32Array.from(native, function (object) { return jsToWasm(object, elementType, types, objectReferences); }), begin >> PTR_SHIFT);
            }
            return new RuntimeArray(arrayPtr, elementType);
        };
        Object.defineProperty(RuntimeArray.prototype, \\"begin\\", {
            get: function () {
                return heapPtr[this.ptr >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RuntimeArray.prototype, \\"back\\", {
            get: function () {
                return heapPtr[(this.ptr + PTR_SIZE) >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Converts a Speedy.js array to a native JS array
         * @param types the reflection information of the object types
         * @param objectReferences map from WASM pointers to the deserialized JS objects
         * @return {Array} the native JS Array
         */
        RuntimeArray.prototype.toArray = function (types, objectReferences) {
            var _this = this;
            switch (this.elementType) {
                case \\"i1\\":
                    return Array.from(heap8.subarray(this.begin, this.back), function (value) { return value !== 0; }); // Elements need to be converted to bool
                case \\"i8\\":
                    return Array.from(heap8.subarray(this.begin, this.back));
                case \\"i32\\":
                    return Array.from(heap32.subarray(this.begin >> 2, this.back >> 2));
                case \\"double\\":
                    return Array.from(heap64.subarray(this.begin >> 3, this.back >> 3));
                default:
                    return Array.from(heapPtr.subarray(this.begin >> PTR_SHIFT, this.back >> PTR_SHIFT), function (objectPtr) { return wasmToJs(objectPtr, _this.elementType, types, objectReferences); });
            }
        };
        return RuntimeArray;
    }());
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    heap8 = new Int8Array(memory.buffer);
    heap32 = heapPtr = new Int32Array(memory.buffer);
    heap64 = new Float64Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    // the top of the heap
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    heap32[GLOBAL_BASE >> 2] = STACK_TOP;
    heap32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = heap32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            // tslint:disable-next-line:no-console
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        heap32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            updateHeap(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== \\"undefined\\" && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module.require;
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    __cxa_allocate_exception: function (size) {
                        return malloc(size);
                    },
                    __cxa_throw: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_find_matching_catch_2: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_free_exception: function (ptr) {
                        try {
                            return free(ptr);
                        }
                        catch (e) {
                            // tslint:disable-next-line:no-console
                            console.error(\\"exception during cxa_free_exception: \\" + e);
                        }
                    },
                    __resumeException: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_atexit: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    pow: Math.pow,
                    fmod: function (x, y) {
                        return x % y;
                    },
                    abort: function (what) {
                        // tslint:disable-next-line:no-console
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    invoke_ii: function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    invoke_iii: function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    invoke_iiii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    invoke_iiiii: function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    invoke_viii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    sbrk: sbrk
                }
            });
        }).then(function (result) {
            instance = result.instance;
            free = instance.exports.free || free;
            malloc = instance.exports.malloc || malloc;
            return instance;
        });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    loader.toWASM = function (jsObject, objectTypeName, types, objectReferences) {
        return jsToWasm(jsObject, objectTypeName, types, objectReferences);
    };
    loader.toJSObject = function (objectPointer, objectTypeName, types) {
        return wasmToJs(objectPointer, objectTypeName, types, new Map());
    };
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
var loadWasmModule_1 = __moduleLoader(\\"./converts-arrays-and-object.wasm\\", { \\"totalStack\\": 532480, \\"initialMemory\\": 16777216, \\"globalBase\\": 8, \\"staticBump\\": 1228, \\"exposeGc\\": false });
class Test {
}
function update(instance, values) { return loadWasmModule_1().then(function instanceLoaded(instance_1) { var types_1 = { \\"double\\": { \\"primitive\\": true, \\"fields\\": [], \\"constructor\\": undefined, \\"typeArguments\\": [] }, \\"Array<double>\\": { \\"primitive\\": false, \\"fields\\": [], \\"constructor\\": Array, \\"typeArguments\\": [\\"double\\"] }, \\"Test\\": { \\"primitive\\": false, \\"fields\\": [{ \\"name\\": \\"updated\\", \\"type\\": \\"i1\\" }, { \\"name\\": \\"value\\", \\"type\\": \\"double\\" }], \\"constructor\\": Test, \\"typeArguments\\": [] }, \\"i1\\": { \\"primitive\\": true, \\"fields\\": [], \\"constructor\\": undefined, \\"typeArguments\\": [] } }; var argumentObjects_1 = new Map(); var result_1 = instance_1.exports._update(loadWasmModule_1.toWASM(instance, \\"Test\\", types_1, argumentObjects_1), loadWasmModule_1.toWASM(values, \\"Array<double>\\", types_1, argumentObjects_1)); loadWasmModule_1.gc(); return result_1; }); }
"
`;

exports[`Transformation converts a returned WASM array to a JS array 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * The code is inspired by https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
function __moduleLoader(wasmUri, options) {
    var PTR_SIZE = 4;
    var PTR_SHIFT = Math.log2(PTR_SIZE);
    function sizeOf(type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return 1;
            case \\"i32\\":
                return 4;
            case \\"double\\":
                return 8;
            default:
                return PTR_SIZE;
        }
    }
    function getHeapValue(ptr, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return heap8[ptr];
            case \\"i32\\":
                return heap32[ptr >> 2] | 0;
            case \\"double\\":
                return heap64[ptr >> 3];
            default:
                return heapPtr[ptr >> PTR_SHIFT] | 0;
        }
    }
    function setHeapValue(ptr, value, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                heap8[ptr] = value;
                break;
            case \\"i32\\":
                heap32[ptr >> 2] = value;
                break;
            case \\"double\\":
                heap64[ptr >> 3] = value;
                break;
            default:
                heapPtr[ptr >> PTR_SHIFT] = value;
        }
    }
    var heap8;
    var heap32;
    var heapPtr;
    var heap64;
    var malloc = function () { throw new Error(\\"malloc not defined\\"); };
    var free = function () { return void 0; };
    function updateHeap(buffer) {
        heap8 = new Int8Array(buffer);
        heap32 = heapPtr = new Int32Array(buffer);
        heap64 = new Float64Array(buffer);
    }
    /**
     * Computes the size of a not packed object
     */
    function computeObjectSize(type) {
        return type.fields.reduce(function (memo, field) {
            var fieldSize = sizeOf(field.type);
            return alignMemory(memo + fieldSize, fieldSize);
        }, 0);
    }
    function jsToWasm(jsValue, typeName, types, objectReferences) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            return jsValue;
        }
        if (jsValue === null) {
            throw new Error(\\"Undefined and null values are not supported\\");
        }
        if (typeof (jsValue) === \\"undefined\\") {
            return 0;
        }
        var ptr = objectReferences.get(jsValue);
        if (typeof (ptr) !== \\"undefined\\") {
            return ptr;
        }
        if (type.constructor === Array) {
            if (!Array.isArray(jsValue)) {
                throw new Error(\\"Expected argument of type Array\\");
            }
            ptr = RuntimeArray.from(jsValue, type.typeArguments[0], types, objectReferences).ptr;
        }
        else {
            // Object
            if (typeof (jsValue) !== \\"object\\") {
                throw new Error(\\"Expected argument of type object but was typeof \\" + typeof (jsValue) + \\".\\");
            }
            if (jsValue.constructor !== type.constructor) {
                throw new Error(\\"Expected object of type \\" + type.constructor + \\" but was \\" + jsValue.constructor + \\" (inheritance is not supported).\\");
            }
            var size = computeObjectSize(type);
            var objPtr = malloc(size);
            if (objPtr === 0) {
                throw new Error(\\"Failed to allocate object\\");
            }
            var offset = 0;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                offset = alignMemory(offset, fieldSize);
                setHeapValue(objPtr + offset, jsToWasm(jsValue[field.name], field.type, types, objectReferences), field.type);
                offset += fieldSize;
            }
            ptr = objPtr;
        }
        objectReferences.set(jsValue, ptr);
        return ptr;
    }
    function wasmToJs(wasmValue, typeName, types, returnedObjects) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            if (typeName === \\"i1\\") {
                return wasmValue !== 0;
            }
            return wasmValue;
        }
        var ptr = wasmValue;
        var objectReference = returnedObjects.get(ptr);
        if (typeof objectReference !== \\"undefined\\") {
            return objectReference;
        }
        if (ptr === 0) {
            return undefined;
        }
        else if (type.constructor === Array) {
            objectReference = new RuntimeArray(ptr, type.typeArguments[0]).toArray(types, returnedObjects);
        }
        else {
            // Object
            var obj = Object.create(type.constructor.prototype); // ensure it is an instance of the class
            var memoryOffset = wasmValue;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                memoryOffset = alignMemory(memoryOffset, fieldSize);
                obj[field.name] = wasmToJs(getHeapValue(memoryOffset, field.type), field.type, types, returnedObjects);
                memoryOffset += fieldSize;
            }
            objectReference = obj;
        }
        returnedObjects.set(ptr, objectReference);
        return objectReference;
    }
    var RuntimeArray = (function () {
        function RuntimeArray(ptr, elementType) {
            this.ptr = ptr;
            this.elementType = elementType;
        }
        /**
         * Allocates a Speedy.js array for the given JS array
         * @param native the js array
         * @param elementType the element type
         * @param types the reflection information of the used types
         * @param objectReferences map from JS to WASM pointers of already deserialized objects
         * @return {RuntimeArray} the Speedy.js Array
         */
        RuntimeArray.from = function (native, elementType, types, objectReferences) {
            // begin, back, capacity
            var size = PTR_SIZE * 2 + sizeOf(\\"i32\\");
            var arrayPtr = malloc(size);
            var elementSize = sizeOf(elementType);
            var elementsPtr = malloc(elementSize * native.length);
            if (arrayPtr === 0 || elementsPtr === 0) {
                throw new Error(\\"Failed to allocate array\\");
            }
            var begin = elementsPtr;
            var back = elementsPtr + (elementSize * native.length);
            heapPtr[arrayPtr >> PTR_SHIFT] = begin;
            heapPtr[(arrayPtr + PTR_SIZE) >> PTR_SHIFT] = back;
            heap32[(arrayPtr + 2 * PTR_SIZE) >> 2] = native.length | 0;
            switch (elementType) {
                case \\"i1\\":
                case \\"i8\\":
                    heap8.set(native, begin);
                    break;
                case \\"i32\\":
                    heap32.set(native, begin >> 2);
                    break;
                case \\"double\\":
                    heap64.set(native, begin >> 3);
                    break;
                default:
                    heapPtr.set(Int32Array.from(native, function (object) { return jsToWasm(object, elementType, types, objectReferences); }), begin >> PTR_SHIFT);
            }
            return new RuntimeArray(arrayPtr, elementType);
        };
        Object.defineProperty(RuntimeArray.prototype, \\"begin\\", {
            get: function () {
                return heapPtr[this.ptr >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RuntimeArray.prototype, \\"back\\", {
            get: function () {
                return heapPtr[(this.ptr + PTR_SIZE) >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Converts a Speedy.js array to a native JS array
         * @param types the reflection information of the object types
         * @param objectReferences map from WASM pointers to the deserialized JS objects
         * @return {Array} the native JS Array
         */
        RuntimeArray.prototype.toArray = function (types, objectReferences) {
            var _this = this;
            switch (this.elementType) {
                case \\"i1\\":
                    return Array.from(heap8.subarray(this.begin, this.back), function (value) { return value !== 0; }); // Elements need to be converted to bool
                case \\"i8\\":
                    return Array.from(heap8.subarray(this.begin, this.back));
                case \\"i32\\":
                    return Array.from(heap32.subarray(this.begin >> 2, this.back >> 2));
                case \\"double\\":
                    return Array.from(heap64.subarray(this.begin >> 3, this.back >> 3));
                default:
                    return Array.from(heapPtr.subarray(this.begin >> PTR_SHIFT, this.back >> PTR_SHIFT), function (objectPtr) { return wasmToJs(objectPtr, _this.elementType, types, objectReferences); });
            }
        };
        return RuntimeArray;
    }());
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    heap8 = new Int8Array(memory.buffer);
    heap32 = heapPtr = new Int32Array(memory.buffer);
    heap64 = new Float64Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    // the top of the heap
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    heap32[GLOBAL_BASE >> 2] = STACK_TOP;
    heap32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = heap32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            // tslint:disable-next-line:no-console
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        heap32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            updateHeap(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== \\"undefined\\" && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module.require;
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    __cxa_allocate_exception: function (size) {
                        return malloc(size);
                    },
                    __cxa_throw: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_find_matching_catch_2: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_free_exception: function (ptr) {
                        try {
                            return free(ptr);
                        }
                        catch (e) {
                            // tslint:disable-next-line:no-console
                            console.error(\\"exception during cxa_free_exception: \\" + e);
                        }
                    },
                    __resumeException: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_atexit: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    pow: Math.pow,
                    fmod: function (x, y) {
                        return x % y;
                    },
                    abort: function (what) {
                        // tslint:disable-next-line:no-console
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    invoke_ii: function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    invoke_iii: function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    invoke_iiii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    invoke_iiiii: function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    invoke_viii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    sbrk: sbrk
                }
            });
        }).then(function (result) {
            instance = result.instance;
            free = instance.exports.free || free;
            malloc = instance.exports.malloc || malloc;
            return instance;
        });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    loader.toWASM = function (jsObject, objectTypeName, types, objectReferences) {
        return jsToWasm(jsObject, objectTypeName, types, objectReferences);
    };
    loader.toJSObject = function (objectPointer, objectTypeName, types) {
        return wasmToJs(objectPointer, objectTypeName, types, new Map());
    };
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
var loadWasmModule_1 = __moduleLoader(\\"./converts-returned-arrays.wasm\\", { \\"totalStack\\": 532480, \\"initialMemory\\": 16777216, \\"globalBase\\": 8, \\"staticBump\\": 1368, \\"exposeGc\\": false });
function update() { return loadWasmModule_1().then(function instanceLoaded(instance_1) { var types_1 = { \\"Array<i32>\\": { \\"primitive\\": false, \\"fields\\": [], \\"constructor\\": Array, \\"typeArguments\\": [\\"i32\\"] }, \\"i32\\": { \\"primitive\\": true, \\"fields\\": [], \\"constructor\\": undefined, \\"typeArguments\\": [] } }; var result_1 = loadWasmModule_1.toJSObject(instance_1.exports._update(), \\"Array<i32>\\", types_1); loadWasmModule_1.gc(); return result_1; }); }
"
`;

exports[`Transformation converts the returned WASM Object to a JS Object 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * The code is inspired by https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
function __moduleLoader(wasmUri, options) {
    var PTR_SIZE = 4;
    var PTR_SHIFT = Math.log2(PTR_SIZE);
    function sizeOf(type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return 1;
            case \\"i32\\":
                return 4;
            case \\"double\\":
                return 8;
            default:
                return PTR_SIZE;
        }
    }
    function getHeapValue(ptr, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return heap8[ptr];
            case \\"i32\\":
                return heap32[ptr >> 2] | 0;
            case \\"double\\":
                return heap64[ptr >> 3];
            default:
                return heapPtr[ptr >> PTR_SHIFT] | 0;
        }
    }
    function setHeapValue(ptr, value, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                heap8[ptr] = value;
                break;
            case \\"i32\\":
                heap32[ptr >> 2] = value;
                break;
            case \\"double\\":
                heap64[ptr >> 3] = value;
                break;
            default:
                heapPtr[ptr >> PTR_SHIFT] = value;
        }
    }
    var heap8;
    var heap32;
    var heapPtr;
    var heap64;
    var malloc = function () { throw new Error(\\"malloc not defined\\"); };
    var free = function () { return void 0; };
    function updateHeap(buffer) {
        heap8 = new Int8Array(buffer);
        heap32 = heapPtr = new Int32Array(buffer);
        heap64 = new Float64Array(buffer);
    }
    /**
     * Computes the size of a not packed object
     */
    function computeObjectSize(type) {
        return type.fields.reduce(function (memo, field) {
            var fieldSize = sizeOf(field.type);
            return alignMemory(memo + fieldSize, fieldSize);
        }, 0);
    }
    function jsToWasm(jsValue, typeName, types, objectReferences) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            return jsValue;
        }
        if (jsValue === null) {
            throw new Error(\\"Undefined and null values are not supported\\");
        }
        if (typeof (jsValue) === \\"undefined\\") {
            return 0;
        }
        var ptr = objectReferences.get(jsValue);
        if (typeof (ptr) !== \\"undefined\\") {
            return ptr;
        }
        if (type.constructor === Array) {
            if (!Array.isArray(jsValue)) {
                throw new Error(\\"Expected argument of type Array\\");
            }
            ptr = RuntimeArray.from(jsValue, type.typeArguments[0], types, objectReferences).ptr;
        }
        else {
            // Object
            if (typeof (jsValue) !== \\"object\\") {
                throw new Error(\\"Expected argument of type object but was typeof \\" + typeof (jsValue) + \\".\\");
            }
            if (jsValue.constructor !== type.constructor) {
                throw new Error(\\"Expected object of type \\" + type.constructor + \\" but was \\" + jsValue.constructor + \\" (inheritance is not supported).\\");
            }
            var size = computeObjectSize(type);
            var objPtr = malloc(size);
            if (objPtr === 0) {
                throw new Error(\\"Failed to allocate object\\");
            }
            var offset = 0;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                offset = alignMemory(offset, fieldSize);
                setHeapValue(objPtr + offset, jsToWasm(jsValue[field.name], field.type, types, objectReferences), field.type);
                offset += fieldSize;
            }
            ptr = objPtr;
        }
        objectReferences.set(jsValue, ptr);
        return ptr;
    }
    function wasmToJs(wasmValue, typeName, types, returnedObjects) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            if (typeName === \\"i1\\") {
                return wasmValue !== 0;
            }
            return wasmValue;
        }
        var ptr = wasmValue;
        var objectReference = returnedObjects.get(ptr);
        if (typeof objectReference !== \\"undefined\\") {
            return objectReference;
        }
        if (ptr === 0) {
            return undefined;
        }
        else if (type.constructor === Array) {
            objectReference = new RuntimeArray(ptr, type.typeArguments[0]).toArray(types, returnedObjects);
        }
        else {
            // Object
            var obj = Object.create(type.constructor.prototype); // ensure it is an instance of the class
            var memoryOffset = wasmValue;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                memoryOffset = alignMemory(memoryOffset, fieldSize);
                obj[field.name] = wasmToJs(getHeapValue(memoryOffset, field.type), field.type, types, returnedObjects);
                memoryOffset += fieldSize;
            }
            objectReference = obj;
        }
        returnedObjects.set(ptr, objectReference);
        return objectReference;
    }
    var RuntimeArray = (function () {
        function RuntimeArray(ptr, elementType) {
            this.ptr = ptr;
            this.elementType = elementType;
        }
        /**
         * Allocates a Speedy.js array for the given JS array
         * @param native the js array
         * @param elementType the element type
         * @param types the reflection information of the used types
         * @param objectReferences map from JS to WASM pointers of already deserialized objects
         * @return {RuntimeArray} the Speedy.js Array
         */
        RuntimeArray.from = function (native, elementType, types, objectReferences) {
            // begin, back, capacity
            var size = PTR_SIZE * 2 + sizeOf(\\"i32\\");
            var arrayPtr = malloc(size);
            var elementSize = sizeOf(elementType);
            var elementsPtr = malloc(elementSize * native.length);
            if (arrayPtr === 0 || elementsPtr === 0) {
                throw new Error(\\"Failed to allocate array\\");
            }
            var begin = elementsPtr;
            var back = elementsPtr + (elementSize * native.length);
            heapPtr[arrayPtr >> PTR_SHIFT] = begin;
            heapPtr[(arrayPtr + PTR_SIZE) >> PTR_SHIFT] = back;
            heap32[(arrayPtr + 2 * PTR_SIZE) >> 2] = native.length | 0;
            switch (elementType) {
                case \\"i1\\":
                case \\"i8\\":
                    heap8.set(native, begin);
                    break;
                case \\"i32\\":
                    heap32.set(native, begin >> 2);
                    break;
                case \\"double\\":
                    heap64.set(native, begin >> 3);
                    break;
                default:
                    heapPtr.set(Int32Array.from(native, function (object) { return jsToWasm(object, elementType, types, objectReferences); }), begin >> PTR_SHIFT);
            }
            return new RuntimeArray(arrayPtr, elementType);
        };
        Object.defineProperty(RuntimeArray.prototype, \\"begin\\", {
            get: function () {
                return heapPtr[this.ptr >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RuntimeArray.prototype, \\"back\\", {
            get: function () {
                return heapPtr[(this.ptr + PTR_SIZE) >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Converts a Speedy.js array to a native JS array
         * @param types the reflection information of the object types
         * @param objectReferences map from WASM pointers to the deserialized JS objects
         * @return {Array} the native JS Array
         */
        RuntimeArray.prototype.toArray = function (types, objectReferences) {
            var _this = this;
            switch (this.elementType) {
                case \\"i1\\":
                    return Array.from(heap8.subarray(this.begin, this.back), function (value) { return value !== 0; }); // Elements need to be converted to bool
                case \\"i8\\":
                    return Array.from(heap8.subarray(this.begin, this.back));
                case \\"i32\\":
                    return Array.from(heap32.subarray(this.begin >> 2, this.back >> 2));
                case \\"double\\":
                    return Array.from(heap64.subarray(this.begin >> 3, this.back >> 3));
                default:
                    return Array.from(heapPtr.subarray(this.begin >> PTR_SHIFT, this.back >> PTR_SHIFT), function (objectPtr) { return wasmToJs(objectPtr, _this.elementType, types, objectReferences); });
            }
        };
        return RuntimeArray;
    }());
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    heap8 = new Int8Array(memory.buffer);
    heap32 = heapPtr = new Int32Array(memory.buffer);
    heap64 = new Float64Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    // the top of the heap
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    heap32[GLOBAL_BASE >> 2] = STACK_TOP;
    heap32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = heap32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            // tslint:disable-next-line:no-console
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        heap32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            updateHeap(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== \\"undefined\\" && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module.require;
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    __cxa_allocate_exception: function (size) {
                        return malloc(size);
                    },
                    __cxa_throw: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_find_matching_catch_2: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_free_exception: function (ptr) {
                        try {
                            return free(ptr);
                        }
                        catch (e) {
                            // tslint:disable-next-line:no-console
                            console.error(\\"exception during cxa_free_exception: \\" + e);
                        }
                    },
                    __resumeException: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_atexit: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    pow: Math.pow,
                    fmod: function (x, y) {
                        return x % y;
                    },
                    abort: function (what) {
                        // tslint:disable-next-line:no-console
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    invoke_ii: function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    invoke_iii: function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    invoke_iiii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    invoke_iiiii: function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    invoke_viii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    sbrk: sbrk
                }
            });
        }).then(function (result) {
            instance = result.instance;
            free = instance.exports.free || free;
            malloc = instance.exports.malloc || malloc;
            return instance;
        });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    loader.toWASM = function (jsObject, objectTypeName, types, objectReferences) {
        return jsToWasm(jsObject, objectTypeName, types, objectReferences);
    };
    loader.toJSObject = function (objectPointer, objectTypeName, types) {
        return wasmToJs(objectPointer, objectTypeName, types, new Map());
    };
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
var loadWasmModule_1 = __moduleLoader(\\"./converts-arrays-and-object.wasm\\", { \\"totalStack\\": 532480, \\"initialMemory\\": 16777216, \\"globalBase\\": 8, \\"staticBump\\": 1228, \\"exposeGc\\": false });
class Test {
}
function update(values) { return loadWasmModule_1().then(function instanceLoaded(instance_1) { var types_1 = { \\"double\\": { \\"primitive\\": true, \\"fields\\": [], \\"constructor\\": undefined, \\"typeArguments\\": [] }, \\"Array<double>\\": { \\"primitive\\": false, \\"fields\\": [], \\"constructor\\": Array, \\"typeArguments\\": [\\"double\\"] } }; var argumentObjects_1 = new Map(); var result_1 = instance_1.exports._update(loadWasmModule_1.toWASM(values, \\"Array<double>\\", types_1, argumentObjects_1)); loadWasmModule_1.gc(); return result_1; }); }
"
`;

exports[`Transformation does not rewrite source files without any speedyjs functions 1`] = `
"function isPrime(value) {
    if (value <= 2) {
        return false;
    }
    for (let i = 2; i <= (Math.sqrt(value) | 0); ++i) {
        if (value % i === 0) {
            return false;
        }
    }
    return true;
}
"
`;

exports[`Transformation emits a diagnostic if a non entry speedyjs function is referenced from normal JavaScriptCode 1`] = `
"test.ts(8,20): error TS100010: SpeedyJS functions referenced from 'normal' JavaScript code needs to be async (the async modifier is missing on the declaration of 'nonEntryFunction').
"
`;

exports[`Transformation emits a diagnostic if a speedy.js function references a regular JavaScript function 1`] = `
"test.ts(9,17): error TS1000033: The Speedy.js function cannot reference the regular JavaScript function 'regularJavaScriptFunction'. Calling JavaScript functions from Speedy.js is not yet supported. Either remove the function call or make the called function a Speedy.js function by adding the \\"use speedyjs\\" directive.
"
`;

exports[`Transformation emits a diagnostic if the entry function has optional parameters 1`] = `
"test.ts(2,51): error TS100011: Optional parameters or variadic parameters are not supported for SpeedyJS entry functions.
"
`;

exports[`Transformation emits a diagnostic if the entry function is generic 1`] = `
"test.ts(1,1): error TS100012: Generic SpeedyJS entry functions are not supported.
"
`;

exports[`Transformation emits a diagnostic if the entry function is overloaded 1`] = `
"test.ts(3,67): error TS100013: SpeedyJS entry function cannot be overloaded.
"
`;

exports[`Transformation exports the gc function if exportGc is set 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * The code is inspired by https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
function __moduleLoader(wasmUri, options) {
    var PTR_SIZE = 4;
    var PTR_SHIFT = Math.log2(PTR_SIZE);
    function sizeOf(type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return 1;
            case \\"i32\\":
                return 4;
            case \\"double\\":
                return 8;
            default:
                return PTR_SIZE;
        }
    }
    function getHeapValue(ptr, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return heap8[ptr];
            case \\"i32\\":
                return heap32[ptr >> 2] | 0;
            case \\"double\\":
                return heap64[ptr >> 3];
            default:
                return heapPtr[ptr >> PTR_SHIFT] | 0;
        }
    }
    function setHeapValue(ptr, value, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                heap8[ptr] = value;
                break;
            case \\"i32\\":
                heap32[ptr >> 2] = value;
                break;
            case \\"double\\":
                heap64[ptr >> 3] = value;
                break;
            default:
                heapPtr[ptr >> PTR_SHIFT] = value;
        }
    }
    var heap8;
    var heap32;
    var heapPtr;
    var heap64;
    var malloc = function () { throw new Error(\\"malloc not defined\\"); };
    var free = function () { return void 0; };
    function updateHeap(buffer) {
        heap8 = new Int8Array(buffer);
        heap32 = heapPtr = new Int32Array(buffer);
        heap64 = new Float64Array(buffer);
    }
    /**
     * Computes the size of a not packed object
     */
    function computeObjectSize(type) {
        return type.fields.reduce(function (memo, field) {
            var fieldSize = sizeOf(field.type);
            return alignMemory(memo + fieldSize, fieldSize);
        }, 0);
    }
    function jsToWasm(jsValue, typeName, types, objectReferences) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            return jsValue;
        }
        if (jsValue === null) {
            throw new Error(\\"Undefined and null values are not supported\\");
        }
        if (typeof (jsValue) === \\"undefined\\") {
            return 0;
        }
        var ptr = objectReferences.get(jsValue);
        if (typeof (ptr) !== \\"undefined\\") {
            return ptr;
        }
        if (type.constructor === Array) {
            if (!Array.isArray(jsValue)) {
                throw new Error(\\"Expected argument of type Array\\");
            }
            ptr = RuntimeArray.from(jsValue, type.typeArguments[0], types, objectReferences).ptr;
        }
        else {
            // Object
            if (typeof (jsValue) !== \\"object\\") {
                throw new Error(\\"Expected argument of type object but was typeof \\" + typeof (jsValue) + \\".\\");
            }
            if (jsValue.constructor !== type.constructor) {
                throw new Error(\\"Expected object of type \\" + type.constructor + \\" but was \\" + jsValue.constructor + \\" (inheritance is not supported).\\");
            }
            var size = computeObjectSize(type);
            var objPtr = malloc(size);
            if (objPtr === 0) {
                throw new Error(\\"Failed to allocate object\\");
            }
            var offset = 0;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                offset = alignMemory(offset, fieldSize);
                setHeapValue(objPtr + offset, jsToWasm(jsValue[field.name], field.type, types, objectReferences), field.type);
                offset += fieldSize;
            }
            ptr = objPtr;
        }
        objectReferences.set(jsValue, ptr);
        return ptr;
    }
    function wasmToJs(wasmValue, typeName, types, returnedObjects) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            if (typeName === \\"i1\\") {
                return wasmValue !== 0;
            }
            return wasmValue;
        }
        var ptr = wasmValue;
        var objectReference = returnedObjects.get(ptr);
        if (typeof objectReference !== \\"undefined\\") {
            return objectReference;
        }
        if (ptr === 0) {
            return undefined;
        }
        else if (type.constructor === Array) {
            objectReference = new RuntimeArray(ptr, type.typeArguments[0]).toArray(types, returnedObjects);
        }
        else {
            // Object
            var obj = Object.create(type.constructor.prototype); // ensure it is an instance of the class
            var memoryOffset = wasmValue;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                memoryOffset = alignMemory(memoryOffset, fieldSize);
                obj[field.name] = wasmToJs(getHeapValue(memoryOffset, field.type), field.type, types, returnedObjects);
                memoryOffset += fieldSize;
            }
            objectReference = obj;
        }
        returnedObjects.set(ptr, objectReference);
        return objectReference;
    }
    var RuntimeArray = (function () {
        function RuntimeArray(ptr, elementType) {
            this.ptr = ptr;
            this.elementType = elementType;
        }
        /**
         * Allocates a Speedy.js array for the given JS array
         * @param native the js array
         * @param elementType the element type
         * @param types the reflection information of the used types
         * @param objectReferences map from JS to WASM pointers of already deserialized objects
         * @return {RuntimeArray} the Speedy.js Array
         */
        RuntimeArray.from = function (native, elementType, types, objectReferences) {
            // begin, back, capacity
            var size = PTR_SIZE * 2 + sizeOf(\\"i32\\");
            var arrayPtr = malloc(size);
            var elementSize = sizeOf(elementType);
            var elementsPtr = malloc(elementSize * native.length);
            if (arrayPtr === 0 || elementsPtr === 0) {
                throw new Error(\\"Failed to allocate array\\");
            }
            var begin = elementsPtr;
            var back = elementsPtr + (elementSize * native.length);
            heapPtr[arrayPtr >> PTR_SHIFT] = begin;
            heapPtr[(arrayPtr + PTR_SIZE) >> PTR_SHIFT] = back;
            heap32[(arrayPtr + 2 * PTR_SIZE) >> 2] = native.length | 0;
            switch (elementType) {
                case \\"i1\\":
                case \\"i8\\":
                    heap8.set(native, begin);
                    break;
                case \\"i32\\":
                    heap32.set(native, begin >> 2);
                    break;
                case \\"double\\":
                    heap64.set(native, begin >> 3);
                    break;
                default:
                    heapPtr.set(Int32Array.from(native, function (object) { return jsToWasm(object, elementType, types, objectReferences); }), begin >> PTR_SHIFT);
            }
            return new RuntimeArray(arrayPtr, elementType);
        };
        Object.defineProperty(RuntimeArray.prototype, \\"begin\\", {
            get: function () {
                return heapPtr[this.ptr >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RuntimeArray.prototype, \\"back\\", {
            get: function () {
                return heapPtr[(this.ptr + PTR_SIZE) >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Converts a Speedy.js array to a native JS array
         * @param types the reflection information of the object types
         * @param objectReferences map from WASM pointers to the deserialized JS objects
         * @return {Array} the native JS Array
         */
        RuntimeArray.prototype.toArray = function (types, objectReferences) {
            var _this = this;
            switch (this.elementType) {
                case \\"i1\\":
                    return Array.from(heap8.subarray(this.begin, this.back), function (value) { return value !== 0; }); // Elements need to be converted to bool
                case \\"i8\\":
                    return Array.from(heap8.subarray(this.begin, this.back));
                case \\"i32\\":
                    return Array.from(heap32.subarray(this.begin >> 2, this.back >> 2));
                case \\"double\\":
                    return Array.from(heap64.subarray(this.begin >> 3, this.back >> 3));
                default:
                    return Array.from(heapPtr.subarray(this.begin >> PTR_SHIFT, this.back >> PTR_SHIFT), function (objectPtr) { return wasmToJs(objectPtr, _this.elementType, types, objectReferences); });
            }
        };
        return RuntimeArray;
    }());
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    heap8 = new Int8Array(memory.buffer);
    heap32 = heapPtr = new Int32Array(memory.buffer);
    heap64 = new Float64Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    // the top of the heap
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    heap32[GLOBAL_BASE >> 2] = STACK_TOP;
    heap32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = heap32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            // tslint:disable-next-line:no-console
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        heap32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            updateHeap(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== \\"undefined\\" && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module.require;
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    __cxa_allocate_exception: function (size) {
                        return malloc(size);
                    },
                    __cxa_throw: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_find_matching_catch_2: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_free_exception: function (ptr) {
                        try {
                            return free(ptr);
                        }
                        catch (e) {
                            // tslint:disable-next-line:no-console
                            console.error(\\"exception during cxa_free_exception: \\" + e);
                        }
                    },
                    __resumeException: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_atexit: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    pow: Math.pow,
                    fmod: function (x, y) {
                        return x % y;
                    },
                    abort: function (what) {
                        // tslint:disable-next-line:no-console
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    invoke_ii: function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    invoke_iii: function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    invoke_iiii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    invoke_iiiii: function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    invoke_viii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    sbrk: sbrk
                }
            });
        }).then(function (result) {
            instance = result.instance;
            free = instance.exports.free || free;
            malloc = instance.exports.malloc || malloc;
            return instance;
        });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    loader.toWASM = function (jsObject, objectTypeName, types, objectReferences) {
        return jsToWasm(jsObject, objectTypeName, types, objectReferences);
    };
    loader.toJSObject = function (objectPointer, objectTypeName, types) {
        return wasmToJs(objectPointer, objectTypeName, types, new Map());
    };
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
var loadWasmModule_1 = __moduleLoader(\\"./fib.wasm\\", { \\"totalStack\\": 532480, \\"initialMemory\\": 16777216, \\"globalBase\\": 8, \\"staticBump\\": 8, \\"exposeGc\\": true });
export const speedyJsGc = loadWasmModule_1.gc;
function fib(value) { return loadWasmModule_1().then(function instanceLoaded(instance_1) { var types_1 = { \\"i32\\": { \\"primitive\\": true, \\"fields\\": [], \\"constructor\\": undefined, \\"typeArguments\\": [] } }; var result_1 = instance_1.exports._fib(value); loadWasmModule_1.gc(); return result_1; }); }
"
`;

exports[`Transformation exposes the gc function if exposeGc is set 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * The code is inspired by https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
function __moduleLoader(wasmUri, options) {
    var PTR_SIZE = 4;
    var PTR_SHIFT = Math.log2(PTR_SIZE);
    function sizeOf(type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return 1;
            case \\"i32\\":
                return 4;
            case \\"double\\":
                return 8;
            default:
                return PTR_SIZE;
        }
    }
    function getHeapValue(ptr, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return heap8[ptr];
            case \\"i32\\":
                return heap32[ptr >> 2] | 0;
            case \\"double\\":
                return heap64[ptr >> 3];
            default:
                return heapPtr[ptr >> PTR_SHIFT] | 0;
        }
    }
    function setHeapValue(ptr, value, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                heap8[ptr] = value;
                break;
            case \\"i32\\":
                heap32[ptr >> 2] = value;
                break;
            case \\"double\\":
                heap64[ptr >> 3] = value;
                break;
            default:
                heapPtr[ptr >> PTR_SHIFT] = value;
        }
    }
    var heap8;
    var heap32;
    var heapPtr;
    var heap64;
    var malloc = function () { throw new Error(\\"malloc not defined\\"); };
    var free = function () { return void 0; };
    function updateHeap(buffer) {
        heap8 = new Int8Array(buffer);
        heap32 = heapPtr = new Int32Array(buffer);
        heap64 = new Float64Array(buffer);
    }
    /**
     * Computes the size of a not packed object
     */
    function computeObjectSize(type) {
        return type.fields.reduce(function (memo, field) {
            var fieldSize = sizeOf(field.type);
            return alignMemory(memo + fieldSize, fieldSize);
        }, 0);
    }
    function jsToWasm(jsValue, typeName, types, objectReferences) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            return jsValue;
        }
        if (jsValue === null) {
            throw new Error(\\"Undefined and null values are not supported\\");
        }
        if (typeof (jsValue) === \\"undefined\\") {
            return 0;
        }
        var ptr = objectReferences.get(jsValue);
        if (typeof (ptr) !== \\"undefined\\") {
            return ptr;
        }
        if (type.constructor === Array) {
            if (!Array.isArray(jsValue)) {
                throw new Error(\\"Expected argument of type Array\\");
            }
            ptr = RuntimeArray.from(jsValue, type.typeArguments[0], types, objectReferences).ptr;
        }
        else {
            // Object
            if (typeof (jsValue) !== \\"object\\") {
                throw new Error(\\"Expected argument of type object but was typeof \\" + typeof (jsValue) + \\".\\");
            }
            if (jsValue.constructor !== type.constructor) {
                throw new Error(\\"Expected object of type \\" + type.constructor + \\" but was \\" + jsValue.constructor + \\" (inheritance is not supported).\\");
            }
            var size = computeObjectSize(type);
            var objPtr = malloc(size);
            if (objPtr === 0) {
                throw new Error(\\"Failed to allocate object\\");
            }
            var offset = 0;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                offset = alignMemory(offset, fieldSize);
                setHeapValue(objPtr + offset, jsToWasm(jsValue[field.name], field.type, types, objectReferences), field.type);
                offset += fieldSize;
            }
            ptr = objPtr;
        }
        objectReferences.set(jsValue, ptr);
        return ptr;
    }
    function wasmToJs(wasmValue, typeName, types, returnedObjects) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            if (typeName === \\"i1\\") {
                return wasmValue !== 0;
            }
            return wasmValue;
        }
        var ptr = wasmValue;
        var objectReference = returnedObjects.get(ptr);
        if (typeof objectReference !== \\"undefined\\") {
            return objectReference;
        }
        if (ptr === 0) {
            return undefined;
        }
        else if (type.constructor === Array) {
            objectReference = new RuntimeArray(ptr, type.typeArguments[0]).toArray(types, returnedObjects);
        }
        else {
            // Object
            var obj = Object.create(type.constructor.prototype); // ensure it is an instance of the class
            var memoryOffset = wasmValue;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                memoryOffset = alignMemory(memoryOffset, fieldSize);
                obj[field.name] = wasmToJs(getHeapValue(memoryOffset, field.type), field.type, types, returnedObjects);
                memoryOffset += fieldSize;
            }
            objectReference = obj;
        }
        returnedObjects.set(ptr, objectReference);
        return objectReference;
    }
    var RuntimeArray = (function () {
        function RuntimeArray(ptr, elementType) {
            this.ptr = ptr;
            this.elementType = elementType;
        }
        /**
         * Allocates a Speedy.js array for the given JS array
         * @param native the js array
         * @param elementType the element type
         * @param types the reflection information of the used types
         * @param objectReferences map from JS to WASM pointers of already deserialized objects
         * @return {RuntimeArray} the Speedy.js Array
         */
        RuntimeArray.from = function (native, elementType, types, objectReferences) {
            // begin, back, capacity
            var size = PTR_SIZE * 2 + sizeOf(\\"i32\\");
            var arrayPtr = malloc(size);
            var elementSize = sizeOf(elementType);
            var elementsPtr = malloc(elementSize * native.length);
            if (arrayPtr === 0 || elementsPtr === 0) {
                throw new Error(\\"Failed to allocate array\\");
            }
            var begin = elementsPtr;
            var back = elementsPtr + (elementSize * native.length);
            heapPtr[arrayPtr >> PTR_SHIFT] = begin;
            heapPtr[(arrayPtr + PTR_SIZE) >> PTR_SHIFT] = back;
            heap32[(arrayPtr + 2 * PTR_SIZE) >> 2] = native.length | 0;
            switch (elementType) {
                case \\"i1\\":
                case \\"i8\\":
                    heap8.set(native, begin);
                    break;
                case \\"i32\\":
                    heap32.set(native, begin >> 2);
                    break;
                case \\"double\\":
                    heap64.set(native, begin >> 3);
                    break;
                default:
                    heapPtr.set(Int32Array.from(native, function (object) { return jsToWasm(object, elementType, types, objectReferences); }), begin >> PTR_SHIFT);
            }
            return new RuntimeArray(arrayPtr, elementType);
        };
        Object.defineProperty(RuntimeArray.prototype, \\"begin\\", {
            get: function () {
                return heapPtr[this.ptr >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RuntimeArray.prototype, \\"back\\", {
            get: function () {
                return heapPtr[(this.ptr + PTR_SIZE) >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Converts a Speedy.js array to a native JS array
         * @param types the reflection information of the object types
         * @param objectReferences map from WASM pointers to the deserialized JS objects
         * @return {Array} the native JS Array
         */
        RuntimeArray.prototype.toArray = function (types, objectReferences) {
            var _this = this;
            switch (this.elementType) {
                case \\"i1\\":
                    return Array.from(heap8.subarray(this.begin, this.back), function (value) { return value !== 0; }); // Elements need to be converted to bool
                case \\"i8\\":
                    return Array.from(heap8.subarray(this.begin, this.back));
                case \\"i32\\":
                    return Array.from(heap32.subarray(this.begin >> 2, this.back >> 2));
                case \\"double\\":
                    return Array.from(heap64.subarray(this.begin >> 3, this.back >> 3));
                default:
                    return Array.from(heapPtr.subarray(this.begin >> PTR_SHIFT, this.back >> PTR_SHIFT), function (objectPtr) { return wasmToJs(objectPtr, _this.elementType, types, objectReferences); });
            }
        };
        return RuntimeArray;
    }());
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    heap8 = new Int8Array(memory.buffer);
    heap32 = heapPtr = new Int32Array(memory.buffer);
    heap64 = new Float64Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    // the top of the heap
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    heap32[GLOBAL_BASE >> 2] = STACK_TOP;
    heap32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = heap32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            // tslint:disable-next-line:no-console
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        heap32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            updateHeap(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== \\"undefined\\" && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module.require;
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    __cxa_allocate_exception: function (size) {
                        return malloc(size);
                    },
                    __cxa_throw: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_find_matching_catch_2: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_free_exception: function (ptr) {
                        try {
                            return free(ptr);
                        }
                        catch (e) {
                            // tslint:disable-next-line:no-console
                            console.error(\\"exception during cxa_free_exception: \\" + e);
                        }
                    },
                    __resumeException: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_atexit: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    pow: Math.pow,
                    fmod: function (x, y) {
                        return x % y;
                    },
                    abort: function (what) {
                        // tslint:disable-next-line:no-console
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    invoke_ii: function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    invoke_iii: function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    invoke_iiii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    invoke_iiiii: function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    invoke_viii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    sbrk: sbrk
                }
            });
        }).then(function (result) {
            instance = result.instance;
            free = instance.exports.free || free;
            malloc = instance.exports.malloc || malloc;
            return instance;
        });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    loader.toWASM = function (jsObject, objectTypeName, types, objectReferences) {
        return jsToWasm(jsObject, objectTypeName, types, objectReferences);
    };
    loader.toJSObject = function (objectPointer, objectTypeName, types) {
        return wasmToJs(objectPointer, objectTypeName, types, new Map());
    };
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
var loadWasmModule_1 = __moduleLoader(\\"./fib.wasm\\", { \\"totalStack\\": 532480, \\"initialMemory\\": 16777216, \\"globalBase\\": 8, \\"staticBump\\": 8, \\"exposeGc\\": true });
const speedyJsGc = loadWasmModule_1.gc;
function fib(value) { return loadWasmModule_1().then(function instanceLoaded(instance_1) { var types_1 = { \\"i32\\": { \\"primitive\\": true, \\"fields\\": [], \\"constructor\\": undefined, \\"typeArguments\\": [] } }; var result_1 = instance_1.exports._fib(value); loadWasmModule_1.gc(); return result_1; }); }
"
`;

exports[`Transformation passes the configured global base to the module loader 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * The code is inspired by https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
function __moduleLoader(wasmUri, options) {
    var PTR_SIZE = 4;
    var PTR_SHIFT = Math.log2(PTR_SIZE);
    function sizeOf(type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return 1;
            case \\"i32\\":
                return 4;
            case \\"double\\":
                return 8;
            default:
                return PTR_SIZE;
        }
    }
    function getHeapValue(ptr, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return heap8[ptr];
            case \\"i32\\":
                return heap32[ptr >> 2] | 0;
            case \\"double\\":
                return heap64[ptr >> 3];
            default:
                return heapPtr[ptr >> PTR_SHIFT] | 0;
        }
    }
    function setHeapValue(ptr, value, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                heap8[ptr] = value;
                break;
            case \\"i32\\":
                heap32[ptr >> 2] = value;
                break;
            case \\"double\\":
                heap64[ptr >> 3] = value;
                break;
            default:
                heapPtr[ptr >> PTR_SHIFT] = value;
        }
    }
    var heap8;
    var heap32;
    var heapPtr;
    var heap64;
    var malloc = function () { throw new Error(\\"malloc not defined\\"); };
    var free = function () { return void 0; };
    function updateHeap(buffer) {
        heap8 = new Int8Array(buffer);
        heap32 = heapPtr = new Int32Array(buffer);
        heap64 = new Float64Array(buffer);
    }
    /**
     * Computes the size of a not packed object
     */
    function computeObjectSize(type) {
        return type.fields.reduce(function (memo, field) {
            var fieldSize = sizeOf(field.type);
            return alignMemory(memo + fieldSize, fieldSize);
        }, 0);
    }
    function jsToWasm(jsValue, typeName, types, objectReferences) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            return jsValue;
        }
        if (jsValue === null) {
            throw new Error(\\"Undefined and null values are not supported\\");
        }
        if (typeof (jsValue) === \\"undefined\\") {
            return 0;
        }
        var ptr = objectReferences.get(jsValue);
        if (typeof (ptr) !== \\"undefined\\") {
            return ptr;
        }
        if (type.constructor === Array) {
            if (!Array.isArray(jsValue)) {
                throw new Error(\\"Expected argument of type Array\\");
            }
            ptr = RuntimeArray.from(jsValue, type.typeArguments[0], types, objectReferences).ptr;
        }
        else {
            // Object
            if (typeof (jsValue) !== \\"object\\") {
                throw new Error(\\"Expected argument of type object but was typeof \\" + typeof (jsValue) + \\".\\");
            }
            if (jsValue.constructor !== type.constructor) {
                throw new Error(\\"Expected object of type \\" + type.constructor + \\" but was \\" + jsValue.constructor + \\" (inheritance is not supported).\\");
            }
            var size = computeObjectSize(type);
            var objPtr = malloc(size);
            if (objPtr === 0) {
                throw new Error(\\"Failed to allocate object\\");
            }
            var offset = 0;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                offset = alignMemory(offset, fieldSize);
                setHeapValue(objPtr + offset, jsToWasm(jsValue[field.name], field.type, types, objectReferences), field.type);
                offset += fieldSize;
            }
            ptr = objPtr;
        }
        objectReferences.set(jsValue, ptr);
        return ptr;
    }
    function wasmToJs(wasmValue, typeName, types, returnedObjects) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            if (typeName === \\"i1\\") {
                return wasmValue !== 0;
            }
            return wasmValue;
        }
        var ptr = wasmValue;
        var objectReference = returnedObjects.get(ptr);
        if (typeof objectReference !== \\"undefined\\") {
            return objectReference;
        }
        if (ptr === 0) {
            return undefined;
        }
        else if (type.constructor === Array) {
            objectReference = new RuntimeArray(ptr, type.typeArguments[0]).toArray(types, returnedObjects);
        }
        else {
            // Object
            var obj = Object.create(type.constructor.prototype); // ensure it is an instance of the class
            var memoryOffset = wasmValue;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                memoryOffset = alignMemory(memoryOffset, fieldSize);
                obj[field.name] = wasmToJs(getHeapValue(memoryOffset, field.type), field.type, types, returnedObjects);
                memoryOffset += fieldSize;
            }
            objectReference = obj;
        }
        returnedObjects.set(ptr, objectReference);
        return objectReference;
    }
    var RuntimeArray = (function () {
        function RuntimeArray(ptr, elementType) {
            this.ptr = ptr;
            this.elementType = elementType;
        }
        /**
         * Allocates a Speedy.js array for the given JS array
         * @param native the js array
         * @param elementType the element type
         * @param types the reflection information of the used types
         * @param objectReferences map from JS to WASM pointers of already deserialized objects
         * @return {RuntimeArray} the Speedy.js Array
         */
        RuntimeArray.from = function (native, elementType, types, objectReferences) {
            // begin, back, capacity
            var size = PTR_SIZE * 2 + sizeOf(\\"i32\\");
            var arrayPtr = malloc(size);
            var elementSize = sizeOf(elementType);
            var elementsPtr = malloc(elementSize * native.length);
            if (arrayPtr === 0 || elementsPtr === 0) {
                throw new Error(\\"Failed to allocate array\\");
            }
            var begin = elementsPtr;
            var back = elementsPtr + (elementSize * native.length);
            heapPtr[arrayPtr >> PTR_SHIFT] = begin;
            heapPtr[(arrayPtr + PTR_SIZE) >> PTR_SHIFT] = back;
            heap32[(arrayPtr + 2 * PTR_SIZE) >> 2] = native.length | 0;
            switch (elementType) {
                case \\"i1\\":
                case \\"i8\\":
                    heap8.set(native, begin);
                    break;
                case \\"i32\\":
                    heap32.set(native, begin >> 2);
                    break;
                case \\"double\\":
                    heap64.set(native, begin >> 3);
                    break;
                default:
                    heapPtr.set(Int32Array.from(native, function (object) { return jsToWasm(object, elementType, types, objectReferences); }), begin >> PTR_SHIFT);
            }
            return new RuntimeArray(arrayPtr, elementType);
        };
        Object.defineProperty(RuntimeArray.prototype, \\"begin\\", {
            get: function () {
                return heapPtr[this.ptr >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RuntimeArray.prototype, \\"back\\", {
            get: function () {
                return heapPtr[(this.ptr + PTR_SIZE) >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Converts a Speedy.js array to a native JS array
         * @param types the reflection information of the object types
         * @param objectReferences map from WASM pointers to the deserialized JS objects
         * @return {Array} the native JS Array
         */
        RuntimeArray.prototype.toArray = function (types, objectReferences) {
            var _this = this;
            switch (this.elementType) {
                case \\"i1\\":
                    return Array.from(heap8.subarray(this.begin, this.back), function (value) { return value !== 0; }); // Elements need to be converted to bool
                case \\"i8\\":
                    return Array.from(heap8.subarray(this.begin, this.back));
                case \\"i32\\":
                    return Array.from(heap32.subarray(this.begin >> 2, this.back >> 2));
                case \\"double\\":
                    return Array.from(heap64.subarray(this.begin >> 3, this.back >> 3));
                default:
                    return Array.from(heapPtr.subarray(this.begin >> PTR_SHIFT, this.back >> PTR_SHIFT), function (objectPtr) { return wasmToJs(objectPtr, _this.elementType, types, objectReferences); });
            }
        };
        return RuntimeArray;
    }());
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    heap8 = new Int8Array(memory.buffer);
    heap32 = heapPtr = new Int32Array(memory.buffer);
    heap64 = new Float64Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    // the top of the heap
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    heap32[GLOBAL_BASE >> 2] = STACK_TOP;
    heap32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = heap32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            // tslint:disable-next-line:no-console
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        heap32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            updateHeap(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== \\"undefined\\" && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module.require;
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    __cxa_allocate_exception: function (size) {
                        return malloc(size);
                    },
                    __cxa_throw: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_find_matching_catch_2: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_free_exception: function (ptr) {
                        try {
                            return free(ptr);
                        }
                        catch (e) {
                            // tslint:disable-next-line:no-console
                            console.error(\\"exception during cxa_free_exception: \\" + e);
                        }
                    },
                    __resumeException: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_atexit: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    pow: Math.pow,
                    fmod: function (x, y) {
                        return x % y;
                    },
                    abort: function (what) {
                        // tslint:disable-next-line:no-console
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    invoke_ii: function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    invoke_iii: function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    invoke_iiii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    invoke_iiiii: function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    invoke_viii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    sbrk: sbrk
                }
            });
        }).then(function (result) {
            instance = result.instance;
            free = instance.exports.free || free;
            malloc = instance.exports.malloc || malloc;
            return instance;
        });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    loader.toWASM = function (jsObject, objectTypeName, types, objectReferences) {
        return jsToWasm(jsObject, objectTypeName, types, objectReferences);
    };
    loader.toJSObject = function (objectPointer, objectTypeName, types) {
        return wasmToJs(objectPointer, objectTypeName, types, new Map());
    };
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
var loadWasmModule_1 = __moduleLoader(\\"./fib.wasm\\", { \\"totalStack\\": 532480, \\"initialMemory\\": 16777216, \\"globalBase\\": 4000, \\"staticBump\\": 8, \\"exposeGc\\": false });
function fib(value) { return loadWasmModule_1().then(function instanceLoaded(instance_1) { var types_1 = { \\"i32\\": { \\"primitive\\": true, \\"fields\\": [], \\"constructor\\": undefined, \\"typeArguments\\": [] } }; var result_1 = instance_1.exports._fib(value); loadWasmModule_1.gc(); return result_1; }); }
"
`;

exports[`Transformation passes the configured initial memory to the module loader 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * The code is inspired by https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
function __moduleLoader(wasmUri, options) {
    var PTR_SIZE = 4;
    var PTR_SHIFT = Math.log2(PTR_SIZE);
    function sizeOf(type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return 1;
            case \\"i32\\":
                return 4;
            case \\"double\\":
                return 8;
            default:
                return PTR_SIZE;
        }
    }
    function getHeapValue(ptr, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return heap8[ptr];
            case \\"i32\\":
                return heap32[ptr >> 2] | 0;
            case \\"double\\":
                return heap64[ptr >> 3];
            default:
                return heapPtr[ptr >> PTR_SHIFT] | 0;
        }
    }
    function setHeapValue(ptr, value, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                heap8[ptr] = value;
                break;
            case \\"i32\\":
                heap32[ptr >> 2] = value;
                break;
            case \\"double\\":
                heap64[ptr >> 3] = value;
                break;
            default:
                heapPtr[ptr >> PTR_SHIFT] = value;
        }
    }
    var heap8;
    var heap32;
    var heapPtr;
    var heap64;
    var malloc = function () { throw new Error(\\"malloc not defined\\"); };
    var free = function () { return void 0; };
    function updateHeap(buffer) {
        heap8 = new Int8Array(buffer);
        heap32 = heapPtr = new Int32Array(buffer);
        heap64 = new Float64Array(buffer);
    }
    /**
     * Computes the size of a not packed object
     */
    function computeObjectSize(type) {
        return type.fields.reduce(function (memo, field) {
            var fieldSize = sizeOf(field.type);
            return alignMemory(memo + fieldSize, fieldSize);
        }, 0);
    }
    function jsToWasm(jsValue, typeName, types, objectReferences) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            return jsValue;
        }
        if (jsValue === null) {
            throw new Error(\\"Undefined and null values are not supported\\");
        }
        if (typeof (jsValue) === \\"undefined\\") {
            return 0;
        }
        var ptr = objectReferences.get(jsValue);
        if (typeof (ptr) !== \\"undefined\\") {
            return ptr;
        }
        if (type.constructor === Array) {
            if (!Array.isArray(jsValue)) {
                throw new Error(\\"Expected argument of type Array\\");
            }
            ptr = RuntimeArray.from(jsValue, type.typeArguments[0], types, objectReferences).ptr;
        }
        else {
            // Object
            if (typeof (jsValue) !== \\"object\\") {
                throw new Error(\\"Expected argument of type object but was typeof \\" + typeof (jsValue) + \\".\\");
            }
            if (jsValue.constructor !== type.constructor) {
                throw new Error(\\"Expected object of type \\" + type.constructor + \\" but was \\" + jsValue.constructor + \\" (inheritance is not supported).\\");
            }
            var size = computeObjectSize(type);
            var objPtr = malloc(size);
            if (objPtr === 0) {
                throw new Error(\\"Failed to allocate object\\");
            }
            var offset = 0;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                offset = alignMemory(offset, fieldSize);
                setHeapValue(objPtr + offset, jsToWasm(jsValue[field.name], field.type, types, objectReferences), field.type);
                offset += fieldSize;
            }
            ptr = objPtr;
        }
        objectReferences.set(jsValue, ptr);
        return ptr;
    }
    function wasmToJs(wasmValue, typeName, types, returnedObjects) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            if (typeName === \\"i1\\") {
                return wasmValue !== 0;
            }
            return wasmValue;
        }
        var ptr = wasmValue;
        var objectReference = returnedObjects.get(ptr);
        if (typeof objectReference !== \\"undefined\\") {
            return objectReference;
        }
        if (ptr === 0) {
            return undefined;
        }
        else if (type.constructor === Array) {
            objectReference = new RuntimeArray(ptr, type.typeArguments[0]).toArray(types, returnedObjects);
        }
        else {
            // Object
            var obj = Object.create(type.constructor.prototype); // ensure it is an instance of the class
            var memoryOffset = wasmValue;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                memoryOffset = alignMemory(memoryOffset, fieldSize);
                obj[field.name] = wasmToJs(getHeapValue(memoryOffset, field.type), field.type, types, returnedObjects);
                memoryOffset += fieldSize;
            }
            objectReference = obj;
        }
        returnedObjects.set(ptr, objectReference);
        return objectReference;
    }
    var RuntimeArray = (function () {
        function RuntimeArray(ptr, elementType) {
            this.ptr = ptr;
            this.elementType = elementType;
        }
        /**
         * Allocates a Speedy.js array for the given JS array
         * @param native the js array
         * @param elementType the element type
         * @param types the reflection information of the used types
         * @param objectReferences map from JS to WASM pointers of already deserialized objects
         * @return {RuntimeArray} the Speedy.js Array
         */
        RuntimeArray.from = function (native, elementType, types, objectReferences) {
            // begin, back, capacity
            var size = PTR_SIZE * 2 + sizeOf(\\"i32\\");
            var arrayPtr = malloc(size);
            var elementSize = sizeOf(elementType);
            var elementsPtr = malloc(elementSize * native.length);
            if (arrayPtr === 0 || elementsPtr === 0) {
                throw new Error(\\"Failed to allocate array\\");
            }
            var begin = elementsPtr;
            var back = elementsPtr + (elementSize * native.length);
            heapPtr[arrayPtr >> PTR_SHIFT] = begin;
            heapPtr[(arrayPtr + PTR_SIZE) >> PTR_SHIFT] = back;
            heap32[(arrayPtr + 2 * PTR_SIZE) >> 2] = native.length | 0;
            switch (elementType) {
                case \\"i1\\":
                case \\"i8\\":
                    heap8.set(native, begin);
                    break;
                case \\"i32\\":
                    heap32.set(native, begin >> 2);
                    break;
                case \\"double\\":
                    heap64.set(native, begin >> 3);
                    break;
                default:
                    heapPtr.set(Int32Array.from(native, function (object) { return jsToWasm(object, elementType, types, objectReferences); }), begin >> PTR_SHIFT);
            }
            return new RuntimeArray(arrayPtr, elementType);
        };
        Object.defineProperty(RuntimeArray.prototype, \\"begin\\", {
            get: function () {
                return heapPtr[this.ptr >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RuntimeArray.prototype, \\"back\\", {
            get: function () {
                return heapPtr[(this.ptr + PTR_SIZE) >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Converts a Speedy.js array to a native JS array
         * @param types the reflection information of the object types
         * @param objectReferences map from WASM pointers to the deserialized JS objects
         * @return {Array} the native JS Array
         */
        RuntimeArray.prototype.toArray = function (types, objectReferences) {
            var _this = this;
            switch (this.elementType) {
                case \\"i1\\":
                    return Array.from(heap8.subarray(this.begin, this.back), function (value) { return value !== 0; }); // Elements need to be converted to bool
                case \\"i8\\":
                    return Array.from(heap8.subarray(this.begin, this.back));
                case \\"i32\\":
                    return Array.from(heap32.subarray(this.begin >> 2, this.back >> 2));
                case \\"double\\":
                    return Array.from(heap64.subarray(this.begin >> 3, this.back >> 3));
                default:
                    return Array.from(heapPtr.subarray(this.begin >> PTR_SHIFT, this.back >> PTR_SHIFT), function (objectPtr) { return wasmToJs(objectPtr, _this.elementType, types, objectReferences); });
            }
        };
        return RuntimeArray;
    }());
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    heap8 = new Int8Array(memory.buffer);
    heap32 = heapPtr = new Int32Array(memory.buffer);
    heap64 = new Float64Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    // the top of the heap
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    heap32[GLOBAL_BASE >> 2] = STACK_TOP;
    heap32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = heap32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            // tslint:disable-next-line:no-console
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        heap32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            updateHeap(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== \\"undefined\\" && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module.require;
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    __cxa_allocate_exception: function (size) {
                        return malloc(size);
                    },
                    __cxa_throw: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_find_matching_catch_2: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_free_exception: function (ptr) {
                        try {
                            return free(ptr);
                        }
                        catch (e) {
                            // tslint:disable-next-line:no-console
                            console.error(\\"exception during cxa_free_exception: \\" + e);
                        }
                    },
                    __resumeException: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_atexit: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    pow: Math.pow,
                    fmod: function (x, y) {
                        return x % y;
                    },
                    abort: function (what) {
                        // tslint:disable-next-line:no-console
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    invoke_ii: function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    invoke_iii: function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    invoke_iiii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    invoke_iiiii: function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    invoke_viii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    sbrk: sbrk
                }
            });
        }).then(function (result) {
            instance = result.instance;
            free = instance.exports.free || free;
            malloc = instance.exports.malloc || malloc;
            return instance;
        });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    loader.toWASM = function (jsObject, objectTypeName, types, objectReferences) {
        return jsToWasm(jsObject, objectTypeName, types, objectReferences);
    };
    loader.toJSObject = function (objectPointer, objectTypeName, types) {
        return wasmToJs(objectPointer, objectTypeName, types, new Map());
    };
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
var loadWasmModule_1 = __moduleLoader(\\"./fib.wasm\\", { \\"totalStack\\": 532480, \\"initialMemory\\": 10485760, \\"globalBase\\": 8, \\"staticBump\\": 8, \\"exposeGc\\": false });
function fib(value) { return loadWasmModule_1().then(function instanceLoaded(instance_1) { var types_1 = { \\"i32\\": { \\"primitive\\": true, \\"fields\\": [], \\"constructor\\": undefined, \\"typeArguments\\": [] } }; var result_1 = instance_1.exports._fib(value); loadWasmModule_1.gc(); return result_1; }); }
"
`;

exports[`Transformation passes the configured total stack to the module loader 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * The code is inspired by https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
function __moduleLoader(wasmUri, options) {
    var PTR_SIZE = 4;
    var PTR_SHIFT = Math.log2(PTR_SIZE);
    function sizeOf(type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return 1;
            case \\"i32\\":
                return 4;
            case \\"double\\":
                return 8;
            default:
                return PTR_SIZE;
        }
    }
    function getHeapValue(ptr, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return heap8[ptr];
            case \\"i32\\":
                return heap32[ptr >> 2] | 0;
            case \\"double\\":
                return heap64[ptr >> 3];
            default:
                return heapPtr[ptr >> PTR_SHIFT] | 0;
        }
    }
    function setHeapValue(ptr, value, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                heap8[ptr] = value;
                break;
            case \\"i32\\":
                heap32[ptr >> 2] = value;
                break;
            case \\"double\\":
                heap64[ptr >> 3] = value;
                break;
            default:
                heapPtr[ptr >> PTR_SHIFT] = value;
        }
    }
    var heap8;
    var heap32;
    var heapPtr;
    var heap64;
    var malloc = function () { throw new Error(\\"malloc not defined\\"); };
    var free = function () { return void 0; };
    function updateHeap(buffer) {
        heap8 = new Int8Array(buffer);
        heap32 = heapPtr = new Int32Array(buffer);
        heap64 = new Float64Array(buffer);
    }
    /**
     * Computes the size of a not packed object
     */
    function computeObjectSize(type) {
        return type.fields.reduce(function (memo, field) {
            var fieldSize = sizeOf(field.type);
            return alignMemory(memo + fieldSize, fieldSize);
        }, 0);
    }
    function jsToWasm(jsValue, typeName, types, objectReferences) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            return jsValue;
        }
        if (jsValue === null) {
            throw new Error(\\"Undefined and null values are not supported\\");
        }
        if (typeof (jsValue) === \\"undefined\\") {
            return 0;
        }
        var ptr = objectReferences.get(jsValue);
        if (typeof (ptr) !== \\"undefined\\") {
            return ptr;
        }
        if (type.constructor === Array) {
            if (!Array.isArray(jsValue)) {
                throw new Error(\\"Expected argument of type Array\\");
            }
            ptr = RuntimeArray.from(jsValue, type.typeArguments[0], types, objectReferences).ptr;
        }
        else {
            // Object
            if (typeof (jsValue) !== \\"object\\") {
                throw new Error(\\"Expected argument of type object but was typeof \\" + typeof (jsValue) + \\".\\");
            }
            if (jsValue.constructor !== type.constructor) {
                throw new Error(\\"Expected object of type \\" + type.constructor + \\" but was \\" + jsValue.constructor + \\" (inheritance is not supported).\\");
            }
            var size = computeObjectSize(type);
            var objPtr = malloc(size);
            if (objPtr === 0) {
                throw new Error(\\"Failed to allocate object\\");
            }
            var offset = 0;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                offset = alignMemory(offset, fieldSize);
                setHeapValue(objPtr + offset, jsToWasm(jsValue[field.name], field.type, types, objectReferences), field.type);
                offset += fieldSize;
            }
            ptr = objPtr;
        }
        objectReferences.set(jsValue, ptr);
        return ptr;
    }
    function wasmToJs(wasmValue, typeName, types, returnedObjects) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            if (typeName === \\"i1\\") {
                return wasmValue !== 0;
            }
            return wasmValue;
        }
        var ptr = wasmValue;
        var objectReference = returnedObjects.get(ptr);
        if (typeof objectReference !== \\"undefined\\") {
            return objectReference;
        }
        if (ptr === 0) {
            return undefined;
        }
        else if (type.constructor === Array) {
            objectReference = new RuntimeArray(ptr, type.typeArguments[0]).toArray(types, returnedObjects);
        }
        else {
            // Object
            var obj = Object.create(type.constructor.prototype); // ensure it is an instance of the class
            var memoryOffset = wasmValue;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                memoryOffset = alignMemory(memoryOffset, fieldSize);
                obj[field.name] = wasmToJs(getHeapValue(memoryOffset, field.type), field.type, types, returnedObjects);
                memoryOffset += fieldSize;
            }
            objectReference = obj;
        }
        returnedObjects.set(ptr, objectReference);
        return objectReference;
    }
    var RuntimeArray = (function () {
        function RuntimeArray(ptr, elementType) {
            this.ptr = ptr;
            this.elementType = elementType;
        }
        /**
         * Allocates a Speedy.js array for the given JS array
         * @param native the js array
         * @param elementType the element type
         * @param types the reflection information of the used types
         * @param objectReferences map from JS to WASM pointers of already deserialized objects
         * @return {RuntimeArray} the Speedy.js Array
         */
        RuntimeArray.from = function (native, elementType, types, objectReferences) {
            // begin, back, capacity
            var size = PTR_SIZE * 2 + sizeOf(\\"i32\\");
            var arrayPtr = malloc(size);
            var elementSize = sizeOf(elementType);
            var elementsPtr = malloc(elementSize * native.length);
            if (arrayPtr === 0 || elementsPtr === 0) {
                throw new Error(\\"Failed to allocate array\\");
            }
            var begin = elementsPtr;
            var back = elementsPtr + (elementSize * native.length);
            heapPtr[arrayPtr >> PTR_SHIFT] = begin;
            heapPtr[(arrayPtr + PTR_SIZE) >> PTR_SHIFT] = back;
            heap32[(arrayPtr + 2 * PTR_SIZE) >> 2] = native.length | 0;
            switch (elementType) {
                case \\"i1\\":
                case \\"i8\\":
                    heap8.set(native, begin);
                    break;
                case \\"i32\\":
                    heap32.set(native, begin >> 2);
                    break;
                case \\"double\\":
                    heap64.set(native, begin >> 3);
                    break;
                default:
                    heapPtr.set(Int32Array.from(native, function (object) { return jsToWasm(object, elementType, types, objectReferences); }), begin >> PTR_SHIFT);
            }
            return new RuntimeArray(arrayPtr, elementType);
        };
        Object.defineProperty(RuntimeArray.prototype, \\"begin\\", {
            get: function () {
                return heapPtr[this.ptr >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RuntimeArray.prototype, \\"back\\", {
            get: function () {
                return heapPtr[(this.ptr + PTR_SIZE) >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Converts a Speedy.js array to a native JS array
         * @param types the reflection information of the object types
         * @param objectReferences map from WASM pointers to the deserialized JS objects
         * @return {Array} the native JS Array
         */
        RuntimeArray.prototype.toArray = function (types, objectReferences) {
            var _this = this;
            switch (this.elementType) {
                case \\"i1\\":
                    return Array.from(heap8.subarray(this.begin, this.back), function (value) { return value !== 0; }); // Elements need to be converted to bool
                case \\"i8\\":
                    return Array.from(heap8.subarray(this.begin, this.back));
                case \\"i32\\":
                    return Array.from(heap32.subarray(this.begin >> 2, this.back >> 2));
                case \\"double\\":
                    return Array.from(heap64.subarray(this.begin >> 3, this.back >> 3));
                default:
                    return Array.from(heapPtr.subarray(this.begin >> PTR_SHIFT, this.back >> PTR_SHIFT), function (objectPtr) { return wasmToJs(objectPtr, _this.elementType, types, objectReferences); });
            }
        };
        return RuntimeArray;
    }());
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    heap8 = new Int8Array(memory.buffer);
    heap32 = heapPtr = new Int32Array(memory.buffer);
    heap64 = new Float64Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    // the top of the heap
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    heap32[GLOBAL_BASE >> 2] = STACK_TOP;
    heap32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = heap32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            // tslint:disable-next-line:no-console
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        heap32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            updateHeap(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== \\"undefined\\" && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module.require;
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    __cxa_allocate_exception: function (size) {
                        return malloc(size);
                    },
                    __cxa_throw: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_find_matching_catch_2: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_free_exception: function (ptr) {
                        try {
                            return free(ptr);
                        }
                        catch (e) {
                            // tslint:disable-next-line:no-console
                            console.error(\\"exception during cxa_free_exception: \\" + e);
                        }
                    },
                    __resumeException: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_atexit: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    pow: Math.pow,
                    fmod: function (x, y) {
                        return x % y;
                    },
                    abort: function (what) {
                        // tslint:disable-next-line:no-console
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    invoke_ii: function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    invoke_iii: function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    invoke_iiii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    invoke_iiiii: function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    invoke_viii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    sbrk: sbrk
                }
            });
        }).then(function (result) {
            instance = result.instance;
            free = instance.exports.free || free;
            malloc = instance.exports.malloc || malloc;
            return instance;
        });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    loader.toWASM = function (jsObject, objectTypeName, types, objectReferences) {
        return jsToWasm(jsObject, objectTypeName, types, objectReferences);
    };
    loader.toJSObject = function (objectPointer, objectTypeName, types) {
        return wasmToJs(objectPointer, objectTypeName, types, new Map());
    };
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
var loadWasmModule_1 = __moduleLoader(\\"./fib.wasm\\", { \\"totalStack\\": 1048576, \\"initialMemory\\": 16777216, \\"globalBase\\": 8, \\"staticBump\\": 8, \\"exposeGc\\": false });
function fib(value) { return loadWasmModule_1().then(function instanceLoaded(instance_1) { var types_1 = { \\"i32\\": { \\"primitive\\": true, \\"fields\\": [], \\"constructor\\": undefined, \\"typeArguments\\": [] } }; var result_1 = instance_1.exports._fib(value); loadWasmModule_1.gc(); return result_1; }); }
"
`;

exports[`Transformation rewrites the speedyjs function to call into the web assembly module 1`] = `
"/**
 * This file includes a single statement, the function declaration of the getWasmModuleFactory. This function is used in the
 * speedyjs-transformer to generate the code to load the wasm module.
 * The code is inspired by https://github.com/kripken/emscripten/blob/incoming/src/runtime.js
 */
function __moduleLoader(wasmUri, options) {
    var PTR_SIZE = 4;
    var PTR_SHIFT = Math.log2(PTR_SIZE);
    function sizeOf(type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return 1;
            case \\"i32\\":
                return 4;
            case \\"double\\":
                return 8;
            default:
                return PTR_SIZE;
        }
    }
    function getHeapValue(ptr, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                return heap8[ptr];
            case \\"i32\\":
                return heap32[ptr >> 2] | 0;
            case \\"double\\":
                return heap64[ptr >> 3];
            default:
                return heapPtr[ptr >> PTR_SHIFT] | 0;
        }
    }
    function setHeapValue(ptr, value, type) {
        switch (type) {
            case \\"i1\\":
            case \\"i8\\":
                heap8[ptr] = value;
                break;
            case \\"i32\\":
                heap32[ptr >> 2] = value;
                break;
            case \\"double\\":
                heap64[ptr >> 3] = value;
                break;
            default:
                heapPtr[ptr >> PTR_SHIFT] = value;
        }
    }
    var heap8;
    var heap32;
    var heapPtr;
    var heap64;
    var malloc = function () { throw new Error(\\"malloc not defined\\"); };
    var free = function () { return void 0; };
    function updateHeap(buffer) {
        heap8 = new Int8Array(buffer);
        heap32 = heapPtr = new Int32Array(buffer);
        heap64 = new Float64Array(buffer);
    }
    /**
     * Computes the size of a not packed object
     */
    function computeObjectSize(type) {
        return type.fields.reduce(function (memo, field) {
            var fieldSize = sizeOf(field.type);
            return alignMemory(memo + fieldSize, fieldSize);
        }, 0);
    }
    function jsToWasm(jsValue, typeName, types, objectReferences) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            return jsValue;
        }
        if (jsValue === null) {
            throw new Error(\\"Undefined and null values are not supported\\");
        }
        if (typeof (jsValue) === \\"undefined\\") {
            return 0;
        }
        var ptr = objectReferences.get(jsValue);
        if (typeof (ptr) !== \\"undefined\\") {
            return ptr;
        }
        if (type.constructor === Array) {
            if (!Array.isArray(jsValue)) {
                throw new Error(\\"Expected argument of type Array\\");
            }
            ptr = RuntimeArray.from(jsValue, type.typeArguments[0], types, objectReferences).ptr;
        }
        else {
            // Object
            if (typeof (jsValue) !== \\"object\\") {
                throw new Error(\\"Expected argument of type object but was typeof \\" + typeof (jsValue) + \\".\\");
            }
            if (jsValue.constructor !== type.constructor) {
                throw new Error(\\"Expected object of type \\" + type.constructor + \\" but was \\" + jsValue.constructor + \\" (inheritance is not supported).\\");
            }
            var size = computeObjectSize(type);
            var objPtr = malloc(size);
            if (objPtr === 0) {
                throw new Error(\\"Failed to allocate object\\");
            }
            var offset = 0;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                offset = alignMemory(offset, fieldSize);
                setHeapValue(objPtr + offset, jsToWasm(jsValue[field.name], field.type, types, objectReferences), field.type);
                offset += fieldSize;
            }
            ptr = objPtr;
        }
        objectReferences.set(jsValue, ptr);
        return ptr;
    }
    function wasmToJs(wasmValue, typeName, types, returnedObjects) {
        var type = types[typeName];
        if (!type) {
            throw new Error(\\"Unknown type \\" + typeName);
        }
        if (type.primitive) {
            if (typeName === \\"i1\\") {
                return wasmValue !== 0;
            }
            return wasmValue;
        }
        var ptr = wasmValue;
        var objectReference = returnedObjects.get(ptr);
        if (typeof objectReference !== \\"undefined\\") {
            return objectReference;
        }
        if (ptr === 0) {
            return undefined;
        }
        else if (type.constructor === Array) {
            objectReference = new RuntimeArray(ptr, type.typeArguments[0]).toArray(types, returnedObjects);
        }
        else {
            // Object
            var obj = Object.create(type.constructor.prototype); // ensure it is an instance of the class
            var memoryOffset = wasmValue;
            for (var _i = 0, _a = type.fields; _i < _a.length; _i++) {
                var field = _a[_i];
                var fieldSize = sizeOf(field.type);
                memoryOffset = alignMemory(memoryOffset, fieldSize);
                obj[field.name] = wasmToJs(getHeapValue(memoryOffset, field.type), field.type, types, returnedObjects);
                memoryOffset += fieldSize;
            }
            objectReference = obj;
        }
        returnedObjects.set(ptr, objectReference);
        return objectReference;
    }
    var RuntimeArray = (function () {
        function RuntimeArray(ptr, elementType) {
            this.ptr = ptr;
            this.elementType = elementType;
        }
        /**
         * Allocates a Speedy.js array for the given JS array
         * @param native the js array
         * @param elementType the element type
         * @param types the reflection information of the used types
         * @param objectReferences map from JS to WASM pointers of already deserialized objects
         * @return {RuntimeArray} the Speedy.js Array
         */
        RuntimeArray.from = function (native, elementType, types, objectReferences) {
            // begin, back, capacity
            var size = PTR_SIZE * 2 + sizeOf(\\"i32\\");
            var arrayPtr = malloc(size);
            var elementSize = sizeOf(elementType);
            var elementsPtr = malloc(elementSize * native.length);
            if (arrayPtr === 0 || elementsPtr === 0) {
                throw new Error(\\"Failed to allocate array\\");
            }
            var begin = elementsPtr;
            var back = elementsPtr + (elementSize * native.length);
            heapPtr[arrayPtr >> PTR_SHIFT] = begin;
            heapPtr[(arrayPtr + PTR_SIZE) >> PTR_SHIFT] = back;
            heap32[(arrayPtr + 2 * PTR_SIZE) >> 2] = native.length | 0;
            switch (elementType) {
                case \\"i1\\":
                case \\"i8\\":
                    heap8.set(native, begin);
                    break;
                case \\"i32\\":
                    heap32.set(native, begin >> 2);
                    break;
                case \\"double\\":
                    heap64.set(native, begin >> 3);
                    break;
                default:
                    heapPtr.set(Int32Array.from(native, function (object) { return jsToWasm(object, elementType, types, objectReferences); }), begin >> PTR_SHIFT);
            }
            return new RuntimeArray(arrayPtr, elementType);
        };
        Object.defineProperty(RuntimeArray.prototype, \\"begin\\", {
            get: function () {
                return heapPtr[this.ptr >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RuntimeArray.prototype, \\"back\\", {
            get: function () {
                return heapPtr[(this.ptr + PTR_SIZE) >> PTR_SHIFT] | 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Converts a Speedy.js array to a native JS array
         * @param types the reflection information of the object types
         * @param objectReferences map from WASM pointers to the deserialized JS objects
         * @return {Array} the native JS Array
         */
        RuntimeArray.prototype.toArray = function (types, objectReferences) {
            var _this = this;
            switch (this.elementType) {
                case \\"i1\\":
                    return Array.from(heap8.subarray(this.begin, this.back), function (value) { return value !== 0; }); // Elements need to be converted to bool
                case \\"i8\\":
                    return Array.from(heap8.subarray(this.begin, this.back));
                case \\"i32\\":
                    return Array.from(heap32.subarray(this.begin >> 2, this.back >> 2));
                case \\"double\\":
                    return Array.from(heap64.subarray(this.begin >> 3, this.back >> 3));
                default:
                    return Array.from(heapPtr.subarray(this.begin >> PTR_SHIFT, this.back >> PTR_SHIFT), function (objectPtr) { return wasmToJs(objectPtr, _this.elementType, types, objectReferences); });
            }
        };
        return RuntimeArray;
    }());
    var TOTAL_STACK = options.totalStack;
    var INITIAL_MEMORY = options.initialMemory;
    var totalMemory = INITIAL_MEMORY;
    var GLOBAL_BASE = options.globalBase;
    var STATIC_BUMP = options.staticBump;
    var WASM_PAGE_SIZE = 64 * 1024;
    var memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / WASM_PAGE_SIZE });
    heap8 = new Int8Array(memory.buffer);
    heap32 = heapPtr = new Int32Array(memory.buffer);
    heap64 = new Float64Array(memory.buffer);
    var STATIC_TOP = GLOBAL_BASE + STATIC_BUMP;
    var STACK_BASE = alignMemory(STATIC_TOP);
    var STACK_TOP = STACK_BASE + TOTAL_STACK;
    var STACK_MAX = STACK_BASE + TOTAL_STACK;
    var DYNAMIC_BASE = alignMemory(STACK_MAX);
    // the top of the heap
    var DYNAMIC_TOP_PTR = STATIC_TOP;
    heap32[GLOBAL_BASE >> 2] = STACK_TOP;
    heap32[DYNAMIC_TOP_PTR >> 2] = DYNAMIC_BASE;
    function sbrk(increment) {
        increment = increment | 0;
        var oldDynamicTop = 0;
        var newDynamicTop = 0;
        increment = ((increment + 15) & -16) | 0;
        oldDynamicTop = heap32[DYNAMIC_TOP_PTR >> 2] | 0;
        newDynamicTop = oldDynamicTop + increment | 0;
        if (((increment | 0) > 0 && (newDynamicTop | 0) < (oldDynamicTop | 0)) // Detect and fail if we would wrap around signed 32-bit int.
            || (newDynamicTop | 0) < 0) {
            // tslint:disable-next-line:no-console
            console.error(\\"Signed 32 wrap around detected\\");
            return -1;
        }
        heap32[DYNAMIC_TOP_PTR >> 2] = newDynamicTop;
        if ((newDynamicTop | 0) > (totalMemory | 0)) {
            var pagesToAdd = 0;
            while ((newDynamicTop | 0) > (totalMemory | 0)) {
                pagesToAdd = (totalMemory / WASM_PAGE_SIZE * 0.5) | 0;
                totalMemory += pagesToAdd * WASM_PAGE_SIZE;
            }
            memory.grow(pagesToAdd);
            updateHeap(memory.buffer);
        }
        return oldDynamicTop | 0;
    }
    function alignMemory(size, quantum) {
        return Math.ceil((size) / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
    }
    function loadInstance() {
        var instance;
        var wasmLoaded;
        // browser
        if (typeof window !== \\"undefined\\") {
            if (typeof fetch !== \\"function\\") {
                throw new Error(\\"Your browser does not support the fetch API. Include a fetch polyfill to load the WASM module\\");
            }
            wasmLoaded = fetch(wasmUri).then(function (response) {
                if (response.ok) {
                    return response.arrayBuffer();
                }
                throw new Error(\\"Failed to load WASM module from \\" + wasmUri + \\" (\\" + response.statusText + \\").\\");
            });
        }
        else if (typeof module !== \\"undefined\\" && module.exports) {
            wasmLoaded = new Promise(function (resolve, reject) {
                // trick webpack to not detect the require call. Webpack should not include the required files as we only
                // want to execute this code if we are in node and use the fetch api in the browser.
                var req = module.require;
                var fs = req(\\"fs\\");
                var path = req(\\"path\\");
                fs.readFile(path.join(__dirname, wasmUri), function (error, data) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(data.buffer);
                    }
                });
            });
        }
        else {
            throw new Error(\\"Unknown environment, can not load WASM module\\");
        }
        return wasmLoaded.then(function (buffer) {
            return WebAssembly.instantiate(buffer, {
                env: {
                    memory: memory,
                    STACKTOP: STACK_TOP,
                    __dso_handle: 0,
                    __cxa_allocate_exception: function (size) {
                        return malloc(size);
                    },
                    __cxa_throw: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_find_matching_catch_2: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_free_exception: function (ptr) {
                        try {
                            return free(ptr);
                        }
                        catch (e) {
                            // tslint:disable-next-line:no-console
                            console.error(\\"exception during cxa_free_exception: \\" + e);
                        }
                    },
                    __resumeException: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    __cxa_atexit: function () {
                        throw new Error(\\"Exceptions not yet supported\\");
                    },
                    pow: Math.pow,
                    fmod: function (x, y) {
                        return x % y;
                    },
                    abort: function (what) {
                        // tslint:disable-next-line:no-console
                        console.error(\\"Abort WASM for reason: \\" + what);
                    },
                    invoke_ii: function (index, a1) {
                        return instance.exports.dynCall_ii(index, a1);
                    },
                    invoke_iii: function (index, a1, a2) {
                        return instance.exports.dynCall_iii(index, a1, a2);
                    },
                    invoke_iiii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_iiii(index, a1, a2, a3);
                    },
                    invoke_iiiii: function (index, a1, a2, a3, a4) {
                        return instance.exports.dynCall_iiiii(index, a1, a2, a3, a4);
                    },
                    invoke_viii: function (index, a1, a2, a3) {
                        return instance.exports.dynCall_viii(index, a1, a2, a3);
                    },
                    sbrk: sbrk
                }
            });
        }).then(function (result) {
            instance = result.instance;
            free = instance.exports.free || free;
            malloc = instance.exports.malloc || malloc;
            return instance;
        });
    }
    var speedyJsGc;
    function gc() {
        if (speedyJsGc) {
            speedyJsGc();
        }
    }
    var loaded;
    var loader = function loader() {
        if (loaded) {
            return loaded;
        }
        loaded = loadInstance().then(function (instance) {
            speedyJsGc = instance.exports.speedyJsGc;
            return instance;
        });
        return loaded;
    };
    loader.gc = gc;
    loader.toWASM = function (jsObject, objectTypeName, types, objectReferences) {
        return jsToWasm(jsObject, objectTypeName, types, objectReferences);
    };
    loader.toJSObject = function (objectPointer, objectTypeName, types) {
        return wasmToJs(objectPointer, objectTypeName, types, new Map());
    };
    return loader;
}
//# sourceMappingURL=get-wasm-module-function.js.map
var loadWasmModule_1 = __moduleLoader(\\"./fib.wasm\\", { \\"totalStack\\": 532480, \\"initialMemory\\": 16777216, \\"globalBase\\": 8, \\"staticBump\\": 8, \\"exposeGc\\": false });
function fib(value) { return loadWasmModule_1().then(function instanceLoaded(instance_1) { var types_1 = { \\"i32\\": { \\"primitive\\": true, \\"fields\\": [], \\"constructor\\": undefined, \\"typeArguments\\": [] } }; var result_1 = instance_1.exports._fib(value); loadWasmModule_1.gc(); return result_1; }); }
"
`;
